{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#dokumentation-fur-die-diplomarbeit-von","title":"Dokumentation f\u00fcr die Diplomarbeit von","text":"<p>Autor: Martin Gspurning</p> <p></p>"},{"location":"milestones/","title":"Meilensteine","text":"Juni 2025 <p>Training des Models f\u00fcr die Buchstabenerkennung und Implementierung in das System.</p> Mai 2025 <p>Refactoring des Codes zur Performance-Steigerung und Optimierung der Algorithmen.</p> April 2025 <p>Entwicklung und Implementierung des Pfadfindungsalgorithmus zur Navigation.</p> M\u00e4rz 2025 <p>Test der Platine und der Sensoren auf Funktionalit\u00e4t und Genauigkeit.</p> Februar 2025 <p>Design und mechanische Planung des Roboters f\u00fcr optimale Beweglichkeit.</p> J\u00e4nner 2025 <p>Entwurf und Erstellung der Platine mit allen notwendigen Schaltungen.</p> Dezember 2024 <p>Recherche und Programmierung der Sensoren zur Datenerfassung und Steuerung.</p> Mitte November 2024 <p>Erste Testl\u00e4ufe und Planung von Messversuchen zur Analyse des Roboters.</p> Anfang November 2024 <p>Start der Code-Strukturierung und Einrichtung eines Git-Repositories f\u00fcr die Projektentwicklung.</p> Ende Oktober 2024 <p>Erarbeitung eines klaren Projektkonzepts und Festlegung der Projektziele.</p> Mitte Oktober 2024 <p>Durchf\u00fchrung von Recherche und Ideensammlung zur Projektentwicklung.</p> Anfang Oktober 2024 <p>Erstellen der Grobstruktur und Begutachtung des Formulars zur Einreichung des Themas.</p> September 2024 <p>Thema eingrenzen, Inhalte, Formulare und Meilensteinplan besprechen und finalisieren.</p>"},{"location":"about/background/","title":"Ziele","text":""},{"location":"about/background/#ziel-der-diplomarbeit","title":"Ziel der Diplomarbeit","text":"<p>Ziel dieser Diplomarbeit ist die Konzeption und Entwicklung eines funktionsf\u00e4higen Bergeroboters, der beim RoboCup Junior zum Einsatz kommen soll. Obwohl eine Teilnahme aufgrund meines Alters au\u00dfer Konkurrenz erfolgt, orientiert sich der Entwurf vollst\u00e4ndig an den offiziellen Regeln und Vorgaben des Wettbewerbs.</p> <p>Der entwickelte Roboter soll folgende Anforderungen erf\u00fcllen:</p> <ul> <li>autonome Fortbewegung,</li> <li>\u00dcberwinden von Hindernissen und</li> <li>Ausf\u00fchren spezifischer Aufgaben wie das gezielte Abwerfen von Erste-Hilfe-Paketen.</li> </ul>"},{"location":"about/background/#umsetzung","title":"Umsetzung","text":"<p>Das Projekt basiert auf dem Arduino Mega 2560R3, welcher in der Programmiersprache C++ programmiert wird. Dieser Mikrocontroller bietet eine Vielzahl von Peripherieanschl\u00fcssen und ein breites Angebot an Open-Source-Ressourcen, die die Entwicklung unterst\u00fctzen.</p>"},{"location":"about/background/#ziel-und-motivation","title":"Ziel und Motivation","text":"<p>Mit dieser Diplomarbeit m\u00f6chte ich die w\u00e4hrend meiner Ausbildungszeit an der HTL-Bulme Graz G\u00f6sting erlernten Kenntnisse und F\u00e4higkeiten in einem interdisziplin\u00e4ren Projekt unter Beweis stellen. Dabei liegt der Fokus darauf, technische Konzepte wie Mikrocontroller-Programmierung, Kommunikationsprotokolle, Elektronik und Bildverarbeitung zu kombinieren, um ein funktionales Endprodukt zu schaffen.</p>"},{"location":"about/background/#inhalt-der-arbeit","title":"Inhalt der Arbeit","text":"<p>Diese Diplomarbeit umfasst folgende Schwerpunkte:</p> <ul> <li>Pulsweitenmodulation mit dem Timer/Counter-Register</li> <li>Kommunikation zwischen dem Arduino Mega 2560R3 (Master) und verschiedenen Sensoren (Slave) mittels I\u00b2C</li> <li>Messung von PWM- und I\u00b2C-Signalen mittels Oszilloskop und Analyse der Messergebnisse</li> <li>Entwurf und Design von Leiterplatten</li> <li>Buchstabenerkennung mittels OpenMV Cam H7 und Machine Learning mit Python</li> </ul> <p>Den vollst\u00e4ndigen Code sowie zus\u00e4tzliche Unterlagen wie Datenbl\u00e4tter und hilfreiche Artikel finden Sie auf MimsRC Github.</p>"},{"location":"about/motivation/","title":"Motivation","text":""},{"location":"about/motivation/#personlicher-hintergrund","title":"Pers\u00f6nlicher Hintergrund","text":"<p>Nach meiner Matura entschied ich mich f\u00fcr eine Doppellehre als Elektro- und Maschinenbautechniker. W\u00e4hrend meiner Lehrzeit habe ich meine Begeisterung f\u00fcr Elektrotechnik, die mir mein Gro\u00dfvater weitergegeben hat, neu entdeckt.  </p> <p>Nach der Lehre wollte ich mich weiterbilden und entschloss mich daher, das Abendkolleg f\u00fcr Elektrotechnik an der HTL Bulme Graz G\u00f6sting zu besuchen. Urspr\u00fcnglich wollte ich den Fachbereich Erneuerbare Energien w\u00e4hlen. Doch schon nach wenigen Wochen weckte der Informatikunterricht, insbesondere das Programmieren, mein Interesse.  </p> <p>Dieser Moment war f\u00fcr mich ein Wendepunkt \u2013 von da an war klar, dass die Automatisierungstechnik genau das Richtige f\u00fcr mich ist.  </p> <p>Im Unterricht wurde mir die Programmiersprache C vermittelt, eine hervorragende Grundlage, um die Prinzipien von Datentypen, Rechenoperationen und Speichermanagement zu verstehen. Diese fundierte Basis hat mich motiviert, mich auch privat mit anderen Programmiersprachen und Technologien auseinanderzusetzen \u2013 ein Vorteil, der mir bei dieser Diplomarbeit zugutekommt.  </p> <p>Die Idee zu diesem Projekt entstand durch meinen Informatik-Professor, Herrn Prof. DI Peter Frauscher, der mit seiner Faszination f\u00fcr Robotik meine Begeisterung weckte.  </p> <p>Mit diesem Projekt m\u00f6chte ich nicht nur meine F\u00e4higkeiten weiterentwickeln, sondern auch zeigen, wie moderne Technologie, auf HTL Niveau in die Praxis umgesetzt werden kann.</p>"},{"location":"about/motivation/#herausforderungen","title":"Herausforderungen","text":"<p>Die Umsetzung eines Bergeroboters f\u00fcr den RoboCup Junior bietet eine Vielzahl technischer und pers\u00f6nlicher Herausforderungen:  </p> <ul> <li>Die Kombination aus Softwareentwicklung und Hardwareintegration.  </li> <li>Die Nutzung von Sensorik, um die Umgebung zu erfassen.  </li> <li>Das Erstellen von Algorithmen, die autonomes Verhalten erm\u00f6glichen.  </li> </ul> <p>Ein weiterer wichtiger Aspekt ist die Erstellung einer umfassenden Dokumentation, um mein Projekt f\u00fcr Interessierte und Technikbegeisterte zug\u00e4nglich zu machen.  </p>"},{"location":"about/motivation/#fachliche-motivation","title":"Fachliche Motivation","text":"<p>W\u00e4hrend meiner Ausbildung an der HTL Bulme Graz G\u00f6sting habe ich fundierte Kenntnisse in Elektrotechnik, Elektronik und Softwareentwicklung erworben. Dieses Projekt gibt mir die Gelegenheit, diese F\u00e4higkeiten in einem praxisorientierten und interdisziplin\u00e4ren Kontext anzuwenden.  </p> <p>Besonders reizt mich die Entwicklung eines autonomen Systems, das in einer unbekannten Umgebung navigieren kann \u2013 eine echte technische Herausforderung, die meine Kreativit\u00e4t und mein technisches Know-how fordert.</p>"},{"location":"about/motivation/#langfristige-ziele","title":"Langfristige Ziele","text":"<p>Mit diesem Projekt m\u00f6chte ich nicht nur meine technischen Fertigkeiten weiter vertiefen, sondern auch meine Probleml\u00f6sungs- und Projektplanungsf\u00e4higkeiten erweitern.  </p> <p>Mein langfristiges Ziel ist es, in der Entwicklung moderner Technologien, insbesondere in den Bereichen Robotik und Automatisierung, t\u00e4tig zu sein. Dieses Projekt stellt f\u00fcr mich einen entscheidenden Meilenstein auf diesem Weg dar.</p>"},{"location":"appendix/ref/","title":"Quellenangaben","text":"<ul> <li> <p>Datenblatt 8-bit Atmel Microcontroller</p> </li> <li> <p>Prescaler Konfiguration</p> </li> <li> <p>Nyquist-Frequenz</p> </li> <li> <p>FFT und LowPass Filter Curio Res</p> </li> <li> <p>I2C von Texas Instrument</p> </li> <li> <p>MkDocs </p> </li> <li> <p>Material f\u00fcr MKDocs </p> </li> <li> <p>PlatformIO</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Git</p> </li> <li> <p>Github</p> </li> <li> <p>[Kaggle] (https://www.kaggle.com/)</p> </li> </ul>"},{"location":"language_tools/cpp/","title":"C++","text":""},{"location":"language_tools/cpp/#uberblick","title":"\u00dcberblick","text":"<p>Die Programmiersprache C++ wurde f\u00fcr die Programmierung des Arduino Mega 2560 verwendet. Sie bietet im Vergleich zu C zus\u00e4tzliche Funktionen wie Klassen, Vererbung und Polymorphismus, die die Entwicklung strukturierter und wiederverwendbarer Software erleichtern.</p>"},{"location":"language_tools/cpp/#vorteile-von-c","title":"Vorteile von C++","text":"<ul> <li>Unterst\u00fctzung f\u00fcr objektorientierte Programmierung.</li> <li>Bessere Organisation von Code durch Klassen.</li> <li>Effiziente Nutzung von Ressourcen dank direkter Speicherverwaltung.  </li> </ul>"},{"location":"language_tools/cpp/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<ul> <li>Steuerung der Motoren und Sensoren des Roboters.</li> <li>Verwaltung der Kommunikationsprotokolle (z. B. I\u00b2C).</li> <li>Nutzung von Timern und Interrupts zur Erzeugung von PWM-Signalen.  </li> </ul>"},{"location":"language_tools/git/","title":"Git und GitHub","text":""},{"location":"language_tools/git/#uberblick","title":"\u00dcberblick","text":"<p>Git ist ein Versionskontrollsystem, das es erm\u00f6glicht, den Code zu verwalten und \u00c4nderungen die von mir get\u00e4tigt wurden  nachzuvollziehen. GitHub ist eine Plattform, die Git zur Verwaltung von Repositories nutzt und zus\u00e4tzlich Werkzeuge f\u00fcr die Zusammenarbeit mit anderen Entwicklern bietet.</p>"},{"location":"language_tools/git/#vorteile-von-gitgithub","title":"Vorteile von Git/GitHub","text":"<ul> <li>Versionskontrolle: Git erm\u00f6glicht es, \u00c4nderungen am Projekt vorzunehmen und jederzeit zu einer fr\u00fcheren Version zur\u00fcckzukehren, solange zuvor ein Commit gemacht wurde.</li> <li>Zusammenarbeit: GitHub erleichtert die Zusammenarbeit, indem \u00c4nderungen \u00fcberpr\u00fcft und Pull Requests erstellt werden k\u00f6nnen, um den Code gemeinsam zu entwickeln.</li> <li>Cloud-basiert: Durch das Hosting auf GitHub ist der Code jederzeit und von \u00fcberall zug\u00e4nglich. </li> <li>Integration: GitHub l\u00e4sst sich nahtlos in viele andere Tools integrieren, wie z.B. in MkDocs zur Erstellung der Dokumentation.</li> </ul>"},{"location":"language_tools/git/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<p>In diesem Projekt wurden Git und GitHub f\u00fcr folgende Zwecke verwendet: - Versionskontrolle des Codes: Jedes Update und jede \u00c4nderung des Codes wurde mit Git verfolgt und auf GitHub gepusht. Besonders n\u00fctzlich ist hierbei der Befehl <code>git log</code>, um den Zeitstrahl mit den Commit-Kommentaren einzusehen. - Projektmanagement: GitHub Issues wurden verwendet, um Aufgaben und Fehler zu dokumentieren. Diese Issues sind direkt in MkDocs integriert, sodass Kommentare und Feedback meines Betreuers auf der Website hinterlegt werden und automatisch ins Repository \u00fcbertragen werden. Dadurch kann ich diese direkt bearbeiten und verfolgen. - Zusammenarbeit: Der Code kann von zuk\u00fcnftigen Projektpartnern oder Mitwirkenden eingesehen und in eigenen Branches erweitert oder optimiert werden. GitHub erm\u00f6glicht es, \u00c4nderungen transparent und nachvollziehbar zu gestalten. - Backup und Cloud-Hosting: Der gesamte Code wird auf GitHub gespeichert, was eine einfache Sicherung und den jederzeitigen Zugriff auf das Projekt erm\u00f6glicht.</p>"},{"location":"language_tools/python/","title":"Python","text":""},{"location":"language_tools/python/#uberblick","title":"\u00dcberblick","text":"<p>Die Programmiersprache Python wurde in verschiedenen Bereichen der Diplomarbeit eingesetzt. Sie kam unter anderem bei der Vorbereitung der Trainingsdaten f\u00fcr das Buchstabenerkennungsmodell sowie bei der Visualisierung von Messdaten aus den verschiedenen Funktionalit\u00e4tsmessungen des Roboters mit dem Oszilloskop zum Einsatz. Weitere Details dazu finden sich im Abschnitt \u00fcber \\(I^2C\\).</p>"},{"location":"language_tools/python/#vorteile-von-python","title":"Vorteile von Python","text":"<ul> <li>Beliebte Programmiersprache mit einer Vielzahl an n\u00fctzlichen Frameworks und Tools.</li> <li>Hervorragende Integration mit anderen Programmen wie LaTeX.</li> <li>Einfaches Erstellen von Diagrammen und Messwertvisualisierungen.</li> <li>Umfangreiche State-of-the-Art Data Science-Frameworks.</li> </ul>"},{"location":"language_tools/python/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<ul> <li>Steuerung der OpenMV Cam H7 und \u00dcbertragung von Informationen an den Arduino Mega 2560.</li> <li>Bildvorbereitung f\u00fcr das Training des Buchstabenerkennungsmodells.</li> <li>Durchf\u00fchrung von Berechnungen mit den Messdaten aus den Messversuchen.</li> <li>Animation von Abl\u00e4ufen mit Manim zur besseren Visualisierung und einem besseren Verst\u00e4ndnis der Abl\u00e4ufe.</li> </ul>"},{"location":"language_tools/start_methods/","title":"Programmiersprachen und Tools","text":"<p>Dieses Kapitel gibt einen \u00dcberblick \u00fcber die in dieser Diplomarbeit verwendeten Programmiersprachen und Tools. F\u00fcr Details zu einer bestimmten Sprache oder einem Tool klicken Sie auf die entsprechenden Links.</p>"},{"location":"language_tools/start_methods/#programmiersprachen","title":"Programmiersprachen","text":"<ul> <li>C++: Hauptsprache f\u00fcr die Entwicklung auf dem Arduino Mega 2560.  </li> <li>Python: F\u00fcr Bildverarbeitung, Datenanalyse und Visualisierung.  </li> <li>HTML und Markdown: F\u00fcr Dokumentation und Website-Gestaltung.  </li> </ul>"},{"location":"language_tools/start_methods/#tools","title":"Tools","text":"<ul> <li>Visual Studio Code: Die IDE meiner Wahl f\u00fcr alle Programmiersprachen.  </li> <li>PlatformIO: Erweiterung f\u00fcr die Programmierung des Arduino Mega.  </li> <li>Marimo: Modernes Notebook zur Messdatenanalyse und Visualisierung.  </li> <li>Git/GitHub: Versionskontrolle und Projektverwaltung.  </li> <li>Mkdocstring: Zur Dokumentation des Codes.  </li> <li>KiCad: Open Source Tool zur Gestaltung des Platinenlayouts.  </li> </ul>"},{"location":"language_tools/vscode/","title":"Visual Studio Code und PlatformIO","text":""},{"location":"language_tools/vscode/#uberblick","title":"\u00dcberblick","text":"<p>Die integrierte Entwicklungsumgebung Visual Studio Code (VS Code) ist eine plattform\u00fcbergreifende IDE (Integrated Development Environment), die eine hohe Anpassbarkeit der Entwicklungsumgebung erm\u00f6glicht. In dieser Umgebung habe ich das Tool PlatformIO installiert, das das Programmieren, Kompilieren und anschlie\u00dfende Hochladen des Codes erm\u00f6glicht.</p>"},{"location":"language_tools/vscode/#vorteile-von-vs-code","title":"Vorteile von VS Code","text":"<ul> <li>Eine der beliebtesten IDEs mit einer Vielzahl an n\u00fctzlichen Plug-ins.</li> <li>All-in-One-L\u00f6sung f\u00fcr die meisten g\u00e4ngigen Programmiersprachen.</li> <li>Vorschau von HTML- und Markdown-Code direkt im Editor.</li> <li>Erm\u00f6glicht die Vorschau von einzelnen Abschnitten der Manim-Animationen.</li> <li>Umfangreiche Dokumentation und starke Community.</li> </ul>"},{"location":"language_tools/vscode/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<p>Der Gro\u00dfteil der Entwicklungsarbeit wurde in Visual Studio Code durchgef\u00fchrt, insbesondere f\u00fcr das Schreiben von Code und das Erstellen von Dokumentationen f\u00fcr das Projekt.</p>"},{"location":"results/i2cDebugging/","title":"I\u00b2C Kommunikation","text":""},{"location":"results/i2cDebugging/#1-aufgabenstellung","title":"1. Aufgabenstellung","text":"<ul> <li>Gewinnung des Messsignals</li> <li>Festlegen der Struktur der Messeinrichtung</li> <li>Bestimmung der Signalformen</li> <li>\u00dcbertragung und Verarbeitung der Messsignale</li> <li>Ausgabe und Darstellung der gewonnenen Information</li> </ul>"},{"location":"results/i2cDebugging/#2-theoretische-grundlagen","title":"2. Theoretische Grundlagen","text":"<p>I\u00b2C ist ein Protokoll, das zwei Leitungen, Serial Data Line (SDA) und Serial Clock Line (SCL), f\u00fcr die Kommunikation verwendet. Das Protokoll unterst\u00fctzt mehrere Teilnehmer und auch mehrere Controller auf einem Kommunikationsbus, die Daten und Steuersignale senden und empfangen. Die Kommunikation findet \u00fcber Byte-Pakete mit einer einmaligen Adresse f\u00fcr jeden Teilnehmer statt.</p>"},{"location":"results/i2cDebugging/#geschwindigkeitsmodi","title":"Geschwindigkeitsmodi","text":"<p>Die I\u00b2C-Kommunikation findet haupts\u00e4chlich in den folgenden drei Modi statt:</p> <ul> <li>Standard-mode (Sm): 100 kilobits pro Sekunde (kbps)</li> <li>Fast-mode (Fm): 400 kilobits pro Sekunde</li> <li>Fast-mode Plus (Fm+): 1 Megabit pro Sekunde (Mbps)</li> </ul> <p>Abb. 1.1: Gegen\u00fcberstellung der Geschwindigkeitsmodi</p> <p></p>"},{"location":"results/i2cDebugging/#aufbau-des-i2c-bus","title":"Aufbau des I\u00b2C-Bus","text":"<p>Abb. 1.2: Schematischer Aufbau eines I\u00b2C Bussystems</p> <p></p>"},{"location":"results/i2cDebugging/#scl-serial-clock","title":"SCL (Serial Clock)","text":"<p>Die Leitung SCL, der serielle Takt, wird haupts\u00e4chlich vom Steuerger\u00e4t (Controller) gesteuert und gibt den Takt f\u00fcr die Daten\u00fcbertragung vor.</p>"},{"location":"results/i2cDebugging/#sda-serial-data","title":"SDA (Serial Data)","text":"<p>Die SDA-Leitung dient zum \u00dcbertragen von Daten zum oder vom Zielger\u00e4t. Ein Controller kann Konfigurationsdaten und Ausgabewerte an einen digitalen-zu-analogen Wandler (DAC) senden, oder ein analog-zu-digital Wandler (ADC) kann Konvertierungsdaten zur\u00fcck an den Controller senden.</p>"},{"location":"results/i2cDebugging/#halbduplex-vs-vollduplex","title":"Halbduplex vs. Vollduplex","text":"<p>I\u00b2C ist eine halbduplexe Kommunikation, bei der nur ein Controller oder Zielger\u00e4t gleichzeitig Daten \u00fcber den Bus sendet. Im Vergleich dazu ist SPI ein vollduplexes Protokoll, bei dem Daten gleichzeitig gesendet und empfangen werden k\u00f6nnen.</p> <p>Vorteile von I\u00b2C: - Geringer Verdrahtungsaufwand - Weniger ben\u00f6tigte Pins am Mikrocontroller</p>"},{"location":"results/i2cDebugging/#i2c-adressierung-und-busstruktur","title":"I\u00b2C Adressierung und Busstruktur","text":"<p>Ein Controller startet und stoppt die I\u00b2C-Kommunikation, wodurch das Risiko eines Buskonflikts vermieden wird. Die Kommunikation mit einem Zielger\u00e4t erfolgt \u00fcber eine eindeutige Adresse auf dem Bus, was sowohl mehrere Controller als auch Zielger\u00e4te auf demselben I\u00b2C-Bus erm\u00f6glicht.</p> <p>SDA- und SCL-Leitungen sind mit allen Ger\u00e4ten auf dem Bus \u00fcber Open-Drain-Verbindungen verbunden, was einen Pull-up-Widerstand erfordert.</p>"},{"location":"results/i2cDebugging/#i2c-start-und-stopp","title":"I\u00b2C Start und Stopp","text":"<p>Die I\u00b2C-Kommunikation wird mit einer START-Bedingung initiiert. Der Controller beansprucht den Bus, indem er zuerst die SDA-Leitung auf Low und dann die SCL-Leitung auf Low zieht. Das Signal einer STOP-Bedingung wird gesendet, indem beide Leitungen wieder auf High gesetzt werden, wodurch der Bus freigegeben wird.</p> <p>Abb. 1.3: Start- und Stoppvorgang der Kommunikation</p> <p></p> <p>Quelle: Texas Instruments</p>"},{"location":"results/i2cDebugging/#3-bauelementdaten","title":"3. Bauelementdaten","text":"<p>Verwendete Bauteile:</p> <ul> <li>2x VL53L0X</li> <li>2x VL53L1X</li> <li>3x VL6180</li> <li>2x TCS3472 RGB Sensor</li> <li>L3GD20H Gyrosensor</li> <li>Oled Display 0,96 Zoll</li> </ul>"},{"location":"results/i2cDebugging/#4-messung-mit-dem-oszilloskop","title":"4. Messung mit dem Oszilloskop","text":"<p>Abb. 2.3: Ausschnitt einer Mussung der I\u00b2C Kommunikation</p> <p></p>"},{"location":"results/i2cDebugging/#5-messergebnisse-und-programmierung","title":"5. Messergebnisse und Programmierung","text":""},{"location":"results/i2cDebugging/#pandas","title":"Pandas","text":"<p>Das Pandas-Framework wird verwendet, um die <code>.csv</code>-Datei zu importieren und zu lesen, die aus der PicoScope7-Software exportiert wurde. Die Datei enth\u00e4lt 64 Buffer-Nummern und zeigt die Kommunikation zwischen dem Arduino Mega und den verwendeten Sensoren. Mit Pandas lassen sich die Daten einfach anzeigen und analysieren.</p>"},{"location":"results/i2cDebugging/#seaborn","title":"Seaborn","text":"<p>F\u00fcr die Datenanalyse und Visualisierung habe ich Seaborn verwendet, eine Python-Bibliothek, die auf Matplotlib basiert. Seaborn bietet eine benutzerfreundliche Schnittstelle f\u00fcr das Erstellen ansprechender und informativer statistischer Grafiken.</p> <p></p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv(\"/path/to/your/file.csv\")\nprint(df.isna())\nprint(df.dropna())\n\ncmap = plt.get_cmap('viridis')\n\n\nsns.histplot(data=df, x=\"Address\", hue='Address', palette='Set1')\nplt.grid(True, axis='x', linestyle='')\nplt.xlabel(\"Addressen\")\nplt.ylabel(\"Anzahl der \u00dcbertragungen\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_Decoding\")\nplt.show()\n\nplt.title(\"Anzahl der Lese- und Schreibvorg\u00e4nge\")\nsns.barplot(data=df[\"R/W\"].value_counts(), palette=\"deep\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\nplt.ylabel(\"Anzahl der Vorg\u00e4nge\")\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_R_W\")\nplt.show()\n\ndf['Time'] = df[\"End Time\"] - df[\"Start Time\"]\nprint(df['Time'])\n\nduration = df['Time'].sum()\nprint(f'L\u00e4nge der Messung: {duration * 1000} ms')\n</code></pre>"},{"location":"results/pwm/","title":"Timer/Counter0 f\u00fcr die Pulsweitenmodulation mit dem Atmega2560","text":""},{"location":"results/pwm/#1-ubersicht","title":"1. \u00dcbersicht","text":"<p>Der Timer/Counter0 ist ein 8-Bit-Z\u00e4hlermodul mit zwei unabh\u00e4ngigen Vergleichseinheiten und Unterst\u00fctzung f\u00fcr die Pulsweitenmodulation (PWM). Diese Funktion erm\u00f6glicht die pr\u00e4zise Steuerung eines generierten Signals. Das folgende Blockdiagramm illustriert den Ablauf:</p> <p>Abb. 1.1: Blockdiagramm </p>"},{"location":"results/pwm/#2-register-uberblick","title":"2. Register \u00dcberblick","text":"<p>Die wichtigsten Register sind:</p> <ul> <li>TCNT0 (Timer/Counter)</li> <li>OCR0A und OCR0B (Output Compare Register)</li> </ul> <p>Diese 8-Bit-Register k\u00f6nnen individuell programmiert werden. Interrupts werden \u00fcber das Timer Interrupt Mask Register (TIMSK0) konfiguriert.</p> <p>Der Timer/Counter kann mit dem internen Mikrokontroller-Takt oder einem externen Taktgeber am Pin T0 betrieben werden. Bei Nutzung des internen Takts kann der Prescaler im Register TCCR0B angepasst werden, um die Timer-Frequenz zu skalieren. Die Berechnung wird sp\u00e4ter genauer erl\u00e4utert.</p> <p>Die OCR0A- und OCR0B-Register werden fortlaufend mit dem Z\u00e4hlerwert verglichen. Das Ergebnis dieses Vergleichs kann zur Signalerzeugung genutzt werden.</p>"},{"location":"results/pwm/#3-detaillierte-registeranalyse-fur-pwm","title":"3. Detaillierte Registeranalyse f\u00fcr PWM","text":""},{"location":"results/pwm/#31-tccr0a","title":"3.1. TCCR0A","text":"<p>Im TCCR0A-Register wird das Bit WGM01 gesetzt, um den Timer in den Clear Timer on Compare Match (CTC)-Modus zu versetzen. In diesem Modus z\u00e4hlt der Timer bis zu einem definierten Wert und wird anschlie\u00dfend zur\u00fcckgesetzt.</p> <p>Abb. 3.1: TCCR0A </p>"},{"location":"results/pwm/#32-tccr0b","title":"3.2. TCCR0B","text":"<p>Im TCCR0B-Register wird das Bit CS01 gesetzt, um den CPU-Takt mit einem Prescaler von 8 zu verwenden.</p> <p>Abb. 3.2: TCCR0B </p>"},{"location":"results/pwm/#33-ocr0a","title":"3.3. OCR0A","text":""},{"location":"results/pwm/#331-funktion","title":"3.3.1. Funktion","text":"<p>Das OCR0A-Register enth\u00e4lt einen 8-Bit-Wert, der mit dem Z\u00e4hler verglichen wird. Bei \u00dcbereinstimmung kann ein Interrupt ausgel\u00f6st werden, der zur PWM genutzt wird. Mit einem Prescaler von 8 wird alle 100 \\(\u00b5s\\) ein Interrupt generiert.</p> <p>Abb. 3.3: OCR0A </p>"},{"location":"results/pwm/#332-berechnung-des-vergleichswertes","title":"3.3.2. Berechnung des Vergleichswertes","text":"<p>Das Ziel ist eine PWM mit 20 \\(Hz\\) f\u00fcr Servomotoren. Die Timer-Frequenz ergibt sich aus dem CPU-Takt und dem Prescaler:</p> \\[ f_{\\text{timertick}} = \\frac{16 \\cdot 10^6 \\, \\text{Hz}}{8} = 2 \\cdot 10^6 \\, \\text{Hz} \\] <p>Ein Timerimpuls wird alle 0,1 \\(ms\\) ben\u00f6tigt:</p> \\[ \\text{ticks}(x) = f\\_{\\text{timertick}} \\cdot x = 2 \\cdot 10^6 \\, \\text{Hz} \\cdot (0.1 \\cdot 10^{-3}) \\, \\text{s} = 200 \\] <p>Der Vergleichswert ergibt sich zu:</p> \\[ OCR0A = \\text{ticks}(x) - 1 = 199 \\]"},{"location":"results/pwm/#34-timsk0","title":"3.4. TIMSK0","text":"<p>Im TIMSK0-Register wird das Bit OCIE0A gesetzt, um den Timer0-Interrupt bei einem Compare-Match zu aktivieren.</p> <p>Abb. 3.4: TCCR0B </p>"},{"location":"results/pwm/#4-grafische-darstellung-der-pwm","title":"4. Grafische Darstellung der PWM","text":"<p>Der modulierte Signalverlauf \u00fcber 3,5 \\(ms\\) zeigt unterschiedliche Pulsweiten, die zur Servomotorsteuerung genutzt werden.</p>"},{"location":"results/pwm/#positionen-des-servomotors","title":"Positionen des Servomotors:","text":"<ul> <li>0\u00b0: 500 \\(\u00b5s\\)</li> <li>90\u00b0: 1450 \\(\u00b5s\\)</li> <li>180\u00b0: 2400 \\(\u00b5s\\)</li> </ul> <p>Abb. 4.1: Signal mit 1ms Pulsweite </p> <p>Abb. 4.2: Signal mit 2ms Pulsweite </p>"},{"location":"results/pwm/#5-frequenzanalyse-des-pwm-signals","title":"5. Frequenzanalyse des PWM-Signals","text":""},{"location":"results/pwm/#51-sampling-frequenz-und-auflosung","title":"5.1. Sampling-Frequenz und Aufl\u00f6sung","text":"<ul> <li>Die Sampling-Frequenz $f_s = 3,13 MS/s $ erf\u00fcllt das Nyquist-Theorem:   $$   f_s &gt; 2 \\cdot f_{\\text{signal}}   $$</li> </ul>"},{"location":"results/pwm/#52-spektrumverteilung","title":"5.2. Spektrumverteilung","text":"<ul> <li>Stark ged\u00e4mpft im h\u00f6heren Frequenzbereich (\\(&lt; -60 dB\\)).</li> </ul>"},{"location":"results/pwm/#53-charakteristische-frequenzkomponenten","title":"5.3. Charakteristische Frequenzkomponenten","text":"<ul> <li>Dominante Grundfrequenz sichtbar bei niedriger Frequenz.</li> </ul>"},{"location":"results/pwm/#54-rauschkomponenten","title":"5.4. Rauschkomponenten","text":"<ul> <li>Hohes Grundrauschen, besonders bei Frequenzen &gt; 0.5 MHz.</li> </ul> <p>Abb. 5.1 Analyse der Frequenzen </p>"},{"location":"results/pwm/#6-programmierung-der-pulsweitenmodulation","title":"6. Programmierung der Pulsweitenmodulation","text":"<pre><code>#include \"RS232.h\"\n#include \"ADU_ATMEGA2560 V21.h\"\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include &lt;util/delay.h&gt;\n#include &lt;Arduino.h&gt;\n\n#define SERVO_1_PIN PE5\n#define SERVO_1_DDR DDRE\n#define SERVO_1_PORT PORTE\n#define SERVO_2_PIN PG5\n#define SERVO_2_DDR DDRG\n#define SERVO_2_PORT PORTG\n\nvolatile uint8_t pulse_length_servo1 = 15;\nvolatile uint8_t pulse_length_servo2 = 15;\nvolatile bool move_to_180 = true;\n\nvoid setup()\n{\n    TCCR0A = (1 &lt;&lt; WGM01);\n    TCCR0B = (1 &lt;&lt; CS01);\n    OCR0A = 199;\n    TIMSK0 = (1 &lt;&lt; OCIE0A);\n\n    SERVO_1_DDR |= (1 &lt;&lt; SERVO_1_PIN);\n    SERVO_2_DDR |= (1 &lt;&lt; SERVO_2_PIN);\n\n    sei();\n\n    ADU_Init();\n    RS232_Init(RS232_NUR_EMPFANGEN);\n}\n\nvoid loop()\n{\n    if (Empfangen == 'u')\n    {\n        if (move_to_180)\n        {\n            pulse_length_servo1 = 24;\n            pulse_length_servo2 = 24;\n        }\n        else\n        {\n            pulse_length_servo1 = 5;\n            pulse_length_servo2 = 5;\n        }\n\n        move_to_180 = !move_to_180;\n        Empfangen = 0;\n    }\n}\n\nISR(TIMER0_COMPA_vect)\n{\n    static uint8_t counter = 0;\n\n    if (counter == 0)\n    {\n        SERVO_1_PORT |= (1 &lt;&lt; SERVO_1_PIN);\n        SERVO_2_PORT |= (1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    if (counter == pulse_length_servo1)\n    {\n        SERVO_1_PORT &amp;= ~(1 &lt;&lt; SERVO_1_PIN);\n    }\n    if (counter == pulse_length_servo2)\n    {\n        SERVO_2_PORT &amp;= ~(1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    counter++;\n    if (counter &gt;= 200)\n    {\n        counter = 0;\n    }\n}\n</code></pre>"},{"location":"results/img/i2cDebugging/","title":"I\u00b2C Kommunikation","text":""},{"location":"results/img/i2cDebugging/#1-aufgabenstellung","title":"1. Aufgabenstellung","text":"<ul> <li>Gewinnung des Messsignals</li> <li>Festlegen der Struktur der Messeinrichtung</li> <li>Bestimmung der Signalformen</li> <li>\u00dcbertragung und Verarbeitung der Messsignale</li> <li>Ausgabe und Darstellung der gewonnenen Information</li> </ul>"},{"location":"results/img/i2cDebugging/#2-theoretische-grundlagen","title":"2. Theoretische Grundlagen","text":"<p>I\u00b2C ist ein Protokoll, das zwei Leitungen, Serial Data Line (SDA) und Serial Clock Line (SCL), f\u00fcr die Kommunikation verwendet. Das Protokoll unterst\u00fctzt mehrere Teilnehmer und auch mehrere Controller auf einem Kommunikationsbus, die Daten und Steuersignale senden und empfangen. Die Kommunikation findet \u00fcber Byte-Pakete mit einer einmaligen Adresse f\u00fcr jeden Teilnehmer statt.</p>"},{"location":"results/img/i2cDebugging/#geschwindigkeitsmodi","title":"Geschwindigkeitsmodi","text":"<p>Die I\u00b2C-Kommunikation findet haupts\u00e4chlich in den folgenden drei Modi statt:</p> <ul> <li>Standard-mode (Sm): 100 kilobits pro Sekunde (kbps)</li> <li>Fast-mode (Fm): 400 kilobits pro Sekunde</li> <li>Fast-mode Plus (Fm+): 1 Megabit pro Sekunde (Mbps)</li> </ul> <p>Abb. 1.1: Gegen\u00fcberstellung der Geschwindigkeitsmodi</p> <p></p>"},{"location":"results/img/i2cDebugging/#aufbau-des-i2c-bus","title":"Aufbau des I\u00b2C-Bus","text":"<p>Abb. 1.2: Schematischer Aufbau eines I\u00b2C Bussystems</p> <p></p>"},{"location":"results/img/i2cDebugging/#scl-serial-clock","title":"SCL (Serial Clock)","text":"<p>Die Leitung SCL, der serielle Takt, wird haupts\u00e4chlich vom Steuerger\u00e4t (Controller) gesteuert und gibt den Takt f\u00fcr die Daten\u00fcbertragung vor.</p>"},{"location":"results/img/i2cDebugging/#sda-serial-data","title":"SDA (Serial Data)","text":"<p>Die SDA-Leitung dient zum \u00dcbertragen von Daten zum oder vom Zielger\u00e4t. Ein Controller kann Konfigurationsdaten und Ausgabewerte an einen digitalen-zu-analogen Wandler (DAC) senden, oder ein analog-zu-digital Wandler (ADC) kann Konvertierungsdaten zur\u00fcck an den Controller senden.</p>"},{"location":"results/img/i2cDebugging/#halbduplex-vs-vollduplex","title":"Halbduplex vs. Vollduplex","text":"<p>I\u00b2C ist eine halbduplexe Kommunikation, bei der nur ein Controller oder Zielger\u00e4t gleichzeitig Daten \u00fcber den Bus sendet. Im Vergleich dazu ist SPI ein vollduplexes Protokoll, bei dem Daten gleichzeitig gesendet und empfangen werden k\u00f6nnen.</p> <p>Vorteile von I\u00b2C: - Geringer Verdrahtungsaufwand - Weniger ben\u00f6tigte Pins am Mikrocontroller</p>"},{"location":"results/img/i2cDebugging/#i2c-adressierung-und-busstruktur","title":"I\u00b2C Adressierung und Busstruktur","text":"<p>Ein Controller startet und stoppt die I\u00b2C-Kommunikation, wodurch das Risiko eines Buskonflikts vermieden wird. Die Kommunikation mit einem Zielger\u00e4t erfolgt \u00fcber eine eindeutige Adresse auf dem Bus, was sowohl mehrere Controller als auch Zielger\u00e4te auf demselben I\u00b2C-Bus erm\u00f6glicht.</p> <p>SDA- und SCL-Leitungen sind mit allen Ger\u00e4ten auf dem Bus \u00fcber Open-Drain-Verbindungen verbunden, was einen Pull-up-Widerstand erfordert.</p>"},{"location":"results/img/i2cDebugging/#i2c-start-und-stopp","title":"I\u00b2C Start und Stopp","text":"<p>Die I\u00b2C-Kommunikation wird mit einer START-Bedingung initiiert. Der Controller beansprucht den Bus, indem er zuerst die SDA-Leitung auf Low und dann die SCL-Leitung auf Low zieht. Das Signal einer STOP-Bedingung wird gesendet, indem beide Leitungen wieder auf High gesetzt werden, wodurch der Bus freigegeben wird.</p> <p>Abb. 1.3: Start- und Stoppvorgang der Kommunikation</p> <p></p> <p>Quelle: Texas Instruments</p>"},{"location":"results/img/i2cDebugging/#3-bauelementdaten","title":"3. Bauelementdaten","text":"<p>Verwendete Bauteile:</p> <ul> <li>2x VL53L0X</li> <li>2x VL53L1X</li> <li>3x VL6180</li> <li>2x TCS3472 RGB Sensor</li> <li>L3GD20H Gyrosensor</li> <li>Oled Display 0,96 Zoll</li> </ul>"},{"location":"results/img/i2cDebugging/#4-messung-mit-dem-oszilloskop","title":"4. Messung mit dem Oszilloskop","text":"<p>Abb. 2.3: Ausschnitt einer Mussung der I\u00b2C Kommunikation</p> <p></p>"},{"location":"results/img/i2cDebugging/#5-messergebnisse-und-programmierung","title":"5. Messergebnisse und Programmierung","text":""},{"location":"results/img/i2cDebugging/#pandas","title":"Pandas","text":"<p>Das Pandas-Framework wird verwendet, um die <code>.csv</code>-Datei zu importieren und zu lesen, die aus der PicoScope7-Software exportiert wurde. Die Datei enth\u00e4lt 64 Buffer-Nummern und zeigt die Kommunikation zwischen dem Arduino Mega und den verwendeten Sensoren. Mit Pandas lassen sich die Daten einfach anzeigen und analysieren.</p>"},{"location":"results/img/i2cDebugging/#seaborn","title":"Seaborn","text":"<p>F\u00fcr die Datenanalyse und Visualisierung habe ich Seaborn verwendet, eine Python-Bibliothek, die auf Matplotlib basiert. Seaborn bietet eine benutzerfreundliche Schnittstelle f\u00fcr das Erstellen ansprechender und informativer statistischer Grafiken.</p> <p></p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv(\"/path/to/your/file.csv\")\nprint(df.isna())\nprint(df.dropna())\n\ncmap = plt.get_cmap('viridis')\n\n\nsns.histplot(data=df, x=\"Address\", hue='Address', palette='Set1')\nplt.grid(True, axis='x', linestyle='')\nplt.xlabel(\"Addressen\")\nplt.ylabel(\"Anzahl der \u00dcbertragungen\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_Decoding\")\nplt.show()\n\nplt.title(\"Anzahl der Lese- und Schreibvorg\u00e4nge\")\nsns.barplot(data=df[\"R/W\"].value_counts(), palette=\"deep\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\nplt.ylabel(\"Anzahl der Vorg\u00e4nge\")\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_R_W\")\nplt.show()\n\ndf['Time'] = df[\"End Time\"] - df[\"Start Time\"]\nprint(df['Time'])\n\nduration = df['Time'].sum()\nprint(f'L\u00e4nge der Messung: {duration * 1000} ms')\n</code></pre>"},{"location":"results/img/pwm/","title":"Timer/Counter0 f\u00fcr die Pulsweitenmodulation mit dem Atmega2560","text":""},{"location":"results/img/pwm/#1-ubersicht","title":"1. \u00dcbersicht","text":"<p>Der Timer/Counter0 ist ein 8-Bit-Z\u00e4hlermodul mit zwei unabh\u00e4ngigen Vergleichseinheiten und Unterst\u00fctzung f\u00fcr die Pulsweitenmodulation (PWM). Diese Funktion erm\u00f6glicht die pr\u00e4zise Steuerung eines generierten Signals. Das folgende Blockdiagramm illustriert den Ablauf:</p> <p>Abb. 1.1: Blockdiagramm </p>"},{"location":"results/img/pwm/#2-register-uberblick","title":"2. Register \u00dcberblick","text":"<p>Die wichtigsten Register sind:</p> <ul> <li>TCNT0 (Timer/Counter)</li> <li>OCR0A und OCR0B (Output Compare Register)</li> </ul> <p>Diese 8-Bit-Register k\u00f6nnen individuell programmiert werden. Interrupts werden \u00fcber das Timer Interrupt Mask Register (TIMSK0) konfiguriert.  </p> <p>Der Timer/Counter kann mit dem internen Mikrokontroller-Takt oder einem externen Taktgeber am Pin T0 betrieben werden. Bei Nutzung des internen Takts kann der Prescaler im Register TCCR0B angepasst werden, um die Timer-Frequenz zu skalieren. Die Berechnung wird sp\u00e4ter genauer erl\u00e4utert.</p> <p>Die OCR0A- und OCR0B-Register werden fortlaufend mit dem Z\u00e4hlerwert verglichen. Das Ergebnis dieses Vergleichs kann zur Signalerzeugung genutzt werden.</p>"},{"location":"results/img/pwm/#3-detaillierte-registeranalyse-fur-pwm","title":"3. Detaillierte Registeranalyse f\u00fcr PWM","text":""},{"location":"results/img/pwm/#31-tccr0a","title":"3.1. TCCR0A","text":"<p>Im TCCR0A-Register wird das Bit WGM01 gesetzt, um den Timer in den Clear Timer on Compare Match (CTC)-Modus zu versetzen. In diesem Modus z\u00e4hlt der Timer bis zu einem definierten Wert und wird anschlie\u00dfend zur\u00fcckgesetzt.</p> <p>Abb. 3.1: TCCR0A </p>"},{"location":"results/img/pwm/#32-tccr0b","title":"3.2. TCCR0B","text":"<p>Im TCCR0B-Register wird das Bit CS01 gesetzt, um den CPU-Takt mit einem Prescaler von 8 zu verwenden.</p> <p>Abb. 3.2: TCCR0B </p>"},{"location":"results/img/pwm/#33-ocr0a","title":"3.3. OCR0A","text":""},{"location":"results/img/pwm/#331-funktion","title":"3.3.1. Funktion","text":"<p>Das OCR0A-Register enth\u00e4lt einen 8-Bit-Wert, der mit dem Z\u00e4hler verglichen wird. Bei \u00dcbereinstimmung kann ein Interrupt ausgel\u00f6st werden, der zur PWM genutzt wird. Mit einem Prescaler von 8 wird alle 100 \u00b5s ein Interrupt generiert.</p> <p>Abb. 3.3: OCR0A </p>"},{"location":"results/img/pwm/#332-berechnung-des-vergleichswertes","title":"3.3.2. Berechnung des Vergleichswertes","text":"<p>Das Ziel ist eine PWM mit 20 Hz f\u00fcr Servomotoren. Die Timer-Frequenz ergibt sich aus dem CPU-Takt und dem Prescaler:</p> \\[ f_{\\text{timertick}} = \\frac{16 \\cdot 10^6 \\, \\text{Hz}}{8} = 2 \\cdot 10^6 \\, \\text{Hz} \\] <p>Ein Timerimpuls wird alle 0,1 ms ben\u00f6tigt:</p> \\[ \\text{ticks}(x) = f_{\\text{timertick}} \\cdot x = 2 \\cdot 10^6 \\cdot 0.1 \\cdot 10^{-3} = 200 \\] <p>Der Vergleichswert ergibt sich zu:</p> \\[ OCR0A = \\text{ticks}(x) - 1 = 199 \\]"},{"location":"results/img/pwm/#34-timsk0","title":"3.4. TIMSK0","text":"<p>Im TIMSK0-Register wird das Bit OCIE0A gesetzt, um den Timer0-Interrupt bei einem Compare-Match zu aktivieren.</p> <p>Abb. 3.4: TCCR0B </p>"},{"location":"results/img/pwm/#4-grafische-darstellung-der-pwm","title":"4. Grafische Darstellung der PWM","text":"<p>Der modulierte Signalverlauf \u00fcber 3,5 ms zeigt unterschiedliche Pulsweiten, die zur Servomotorsteuerung genutzt werden.  </p>"},{"location":"results/img/pwm/#positionen-des-servomotors","title":"Positionen des Servomotors:","text":"<ul> <li>0\u00b0: 500 \u00b5s</li> <li>90\u00b0: 1450 \u00b5s</li> <li>180\u00b0: 2400 \u00b5s</li> </ul> <p>Abb. 4.1: Signal mit minimaler Pulsweite (1 ms) </p> <p>Abb. 4.2: Signal mit maximaler Pulsweite (2 ms) </p>"},{"location":"results/img/pwm/#5-frequenzanalyse-des-pwm-signals","title":"5. Frequenzanalyse des PWM-Signals","text":""},{"location":"results/img/pwm/#51-sampling-frequenz-und-auflosung","title":"5.1. Sampling-Frequenz und Aufl\u00f6sung","text":"<ul> <li>Die Sampling-Frequenz f_s = 3,13 MS/s erf\u00fcllt das Nyquist-Theorem:  $$ f_s &gt; 2 \\cdot f_{\\text{signal}} $$</li> </ul>"},{"location":"results/img/pwm/#52-spektrumverteilung","title":"5.2. Spektrumverteilung","text":"<ul> <li>Stark ged\u00e4mpft im h\u00f6heren Frequenzbereich (&lt; -60 dB).</li> </ul>"},{"location":"results/img/pwm/#53-charakteristische-frequenzkomponenten","title":"5.3. Charakteristische Frequenzkomponenten","text":"<ul> <li>Dominante Grundfrequenz sichtbar bei niedriger Frequenz.</li> </ul>"},{"location":"results/img/pwm/#54-rauschkomponenten","title":"5.4. Rauschkomponenten","text":"<ul> <li>Hohes Grundrauschen, besonders bei Frequenzen &gt; 0.5 MHz.</li> </ul> <p>Abb. 5.1 Analyse der Frequenzen </p>"},{"location":"results/img/pwm/#6-programmierung-der-pulsweitenmodulation","title":"6. Programmierung der Pulsweitenmodulation","text":"<pre><code>#include \"RS232.h\"\n#include \"ADU_ATMEGA2560 V21.h\"\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include &lt;util/delay.h&gt;\n#include &lt;Arduino.h&gt;\n\n#define SERVO_1_PIN PE5\n#define SERVO_1_DDR DDRE\n#define SERVO_1_PORT PORTE\n#define SERVO_2_PIN PG5\n#define SERVO_2_DDR DDRG\n#define SERVO_2_PORT PORTG\n\nvolatile uint8_t pulse_length_servo1 = 15;\nvolatile uint8_t pulse_length_servo2 = 15;\nvolatile bool move_to_180 = true;\n\nvoid setup()\n{\n    TCCR0A = (1 &lt;&lt; WGM01);\n    TCCR0B = (1 &lt;&lt; CS01);\n    OCR0A = 199;\n    TIMSK0 = (1 &lt;&lt; OCIE0A);\n\n    SERVO_1_DDR |= (1 &lt;&lt; SERVO_1_PIN);\n    SERVO_2_DDR |= (1 &lt;&lt; SERVO_2_PIN);\n\n    sei();\n\n    ADU_Init();\n    RS232_Init(RS232_NUR_EMPFANGEN);\n}\n\nvoid loop()\n{\n    if (Empfangen == 'u')\n    {\n        if (move_to_180)\n        {\n            pulse_length_servo1 = 24;\n            pulse_length_servo2 = 24;\n        }\n        else\n        {\n            pulse_length_servo1 = 5;\n            pulse_length_servo2 = 5;\n        }\n\n        move_to_180 = !move_to_180;\n        Empfangen = 0;\n    }\n}\n\nISR(TIMER0_COMPA_vect)\n{\n    static uint8_t counter = 0;\n\n    if (counter == 0)\n    {\n        SERVO_1_PORT |= (1 &lt;&lt; SERVO_1_PIN);\n        SERVO_2_PORT |= (1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    if (counter == pulse_length_servo1)\n    {\n        SERVO_1_PORT &amp;= ~(1 &lt;&lt; SERVO_1_PIN);\n    }\n    if (counter == pulse_length_servo2)\n    {\n        SERVO_2_PORT &amp;= ~(1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    counter++;\n    if (counter &gt;= 200)\n    {\n        counter = 0;\n    }\n}\n</code></pre>"}]}