{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MimsRC","text":""},{"location":"#ziel-der-diplomarbeit","title":"Ziel der Diplomarbeit","text":"<p>Das Ziel dieser Diplomarbeit ist die Konzeption und Entwicklung eines funktionsf\u00e4higen Bergeroboters, der beim RoboCup Junior zum Einsatz kommt. Obwohl die Teilnahme aufgrund meines Alters au\u00dfer Konkurrenz erfolgt, orientiert sich der Entwurf vollst\u00e4ndig an den Regeln und Vorgaben des Wettbewerbs.</p> <p>Der entwickelte Roboter soll unterschiedliche Anforderungen erf\u00fcllen, wie zum Beispiel:</p> <ul> <li>sich eigenst\u00e4ndig fortzubewegen,</li> <li>Hindernisse zu \u00fcberwinden und</li> <li>spezifische Aufgaben zu erf\u00fcllen, wie das gezielte Abwerfen von Erste-Hilfe-Paketen.</li> </ul>"},{"location":"#umsetzung","title":"Umsetzung","text":"<p>Das Projekt wird mit dem Arduino Mega 2560R3 umgesetzt, welcher mit der Programmiersprache C++ programmiert wurde. Dieser Mikrocontroller bietet eine Vielzahl an Peripherieanschl\u00fcssen und ein breites Angebot an Open-Source-Quellen, die f\u00fcr die Programmierung hilfreich sind.</p>"},{"location":"#ziel-und-motivation","title":"Ziel und Motivation","text":"<p>Mit dieser Diplomarbeit m\u00f6chte ich meine w\u00e4hrend der Ausbildungszeit an der HTL-Bulme Graz G\u00f6sting erlernten Kenntnisse und F\u00e4higkeiten unter Beweis stellen. Zudem m\u00f6chte ich aufzeigen, wie technische Konzepte wie Mikrocontroller-Programmierung, Kommunikationsprotokolle, Elektronik und Bildverarbeitung in einem praktischen, interdisziplin\u00e4ren Projekt kombiniert werden k\u00f6nnen, um ein funktionales Endprodukt zu erschaffen.</p>"},{"location":"#diese-arbeit-umfasst","title":"Diese Arbeit umfasst:","text":"<ul> <li> <p>Pulsweitenmodulation mit dem Timer/Counter Register</p> </li> <li> <p>Kommunikation zwischen dem Arduino Mega 2560R3 (Master) und den verschiedenen Sensoren (Slave) mittels I\u00b2C</p> </li> <li> <p>Messung von PWM und I\u00b2C mittels Oszilloskop und Analyse der Messungen</p> </li> <li> <p>Platinendesign</p> </li> <li> <p>Buchstabenerkennung mittels OpenMV Cam H7 und Machine Learning mit Python</p> </li> </ul> <p>Den vollst\u00e4ndigen Code, Unterlagen wie zum Beispiel Datenbl\u00e4tter und Hilfreiche Artikel kann man unter MimsRC Github genauer durchsuchen.</p>"},{"location":"about/","title":"Home","text":""},{"location":"about/#dokumentation-fur-die-diplomarbeit-von","title":"Dokumentation f\u00fcr die Diplomarbeit von","text":"<p>Autor: Martin Gspurning</p>"},{"location":"about/#_2","title":"Home","text":""},{"location":"i2cDebugging/","title":"I\u00b2C Kommunikation","text":""},{"location":"i2cDebugging/#1-aufgabenstellung","title":"1. Aufgabenstellung","text":"<ul> <li>Gewinnung des Messsignals</li> <li>Festlegen der Struktur der Messeinrichtung</li> <li>Bestimmung der Signalformen</li> <li>\u00dcbertragung und Verarbeitung der Messsignale</li> <li>Ausgabe und Darstellung der gewonnenen Information</li> </ul>"},{"location":"i2cDebugging/#2-theoretische-grundlagen","title":"2. Theoretische Grundlagen","text":"<p>I\u00b2C ist ein Protokoll, das zwei Leitungen, Serial Data Line (SDA) und Serial Clock Line (SCL), f\u00fcr die Kommunikation verwendet. Das Protokoll unterst\u00fctzt mehrere Teilnehmer und auch mehrere Controller auf einem Kommunikationsbus, die Daten und Steuersignale senden und empfangen. Die Kommunikation findet \u00fcber Byte-Pakete mit einer einmaligen Adresse f\u00fcr jeden Teilnehmer statt.</p>"},{"location":"i2cDebugging/#geschwindigkeitsmodi","title":"Geschwindigkeitsmodi","text":"<p>Die I\u00b2C-Kommunikation findet haupts\u00e4chlich in den folgenden drei Modi statt:</p> <ul> <li>Standard-mode (Sm): 100 kilobits pro Sekunde (kbps)</li> <li>Fast-mode (Fm): 400 kilobits pro Sekunde</li> <li>Fast-mode Plus (Fm+): 1 Megabit pro Sekunde (Mbps)</li> </ul> <p>Abb. 1.1: Gegen\u00fcberstellung der Geschwindigkeitsmodi</p> <p></p>"},{"location":"i2cDebugging/#aufbau-des-i2c-bus","title":"Aufbau des I\u00b2C-Bus","text":"<p>Abb. 1.2: Schematischer Aufbau eines I\u00b2C Bussystems</p> <p></p>"},{"location":"i2cDebugging/#scl-serial-clock","title":"SCL (Serial Clock)","text":"<p>Die Leitung SCL, der serielle Takt, wird haupts\u00e4chlich vom Steuerger\u00e4t (Controller) gesteuert und gibt den Takt f\u00fcr die Daten\u00fcbertragung vor.</p>"},{"location":"i2cDebugging/#sda-serial-data","title":"SDA (Serial Data)","text":"<p>Die SDA-Leitung dient zum \u00dcbertragen von Daten zum oder vom Zielger\u00e4t. Ein Controller kann Konfigurationsdaten und Ausgabewerte an einen digitalen-zu-analogen Wandler (DAC) senden, oder ein analog-zu-digital Wandler (ADC) kann Konvertierungsdaten zur\u00fcck an den Controller senden.</p>"},{"location":"i2cDebugging/#halbduplex-vs-vollduplex","title":"Halbduplex vs. Vollduplex","text":"<p>I\u00b2C ist eine halbduplexe Kommunikation, bei der nur ein Controller oder Zielger\u00e4t gleichzeitig Daten \u00fcber den Bus sendet. Im Vergleich dazu ist SPI ein vollduplexes Protokoll, bei dem Daten gleichzeitig gesendet und empfangen werden k\u00f6nnen.</p> <p>Vorteile von I\u00b2C: - Geringer Verdrahtungsaufwand - Weniger ben\u00f6tigte Pins am Mikrocontroller</p>"},{"location":"i2cDebugging/#i2c-adressierung-und-busstruktur","title":"I\u00b2C Adressierung und Busstruktur","text":"<p>Ein Controller startet und stoppt die I\u00b2C-Kommunikation, wodurch das Risiko eines Buskonflikts vermieden wird. Die Kommunikation mit einem Zielger\u00e4t erfolgt \u00fcber eine eindeutige Adresse auf dem Bus, was sowohl mehrere Controller als auch Zielger\u00e4te auf demselben I\u00b2C-Bus erm\u00f6glicht.</p> <p>SDA- und SCL-Leitungen sind mit allen Ger\u00e4ten auf dem Bus \u00fcber Open-Drain-Verbindungen verbunden, was einen Pull-up-Widerstand erfordert.</p>"},{"location":"i2cDebugging/#i2c-start-und-stopp","title":"I\u00b2C Start und Stopp","text":"<p>Die I\u00b2C-Kommunikation wird mit einer START-Bedingung initiiert. Der Controller beansprucht den Bus, indem er zuerst die SDA-Leitung auf Low und dann die SCL-Leitung auf Low zieht. Das Signal einer STOP-Bedingung wird gesendet, indem beide Leitungen wieder auf High gesetzt werden, wodurch der Bus freigegeben wird.</p> <p>Abb. 1.3: Start- und Stoppvorgang der Kommunikation</p> <p></p> <p>Quelle: Texas Instruments</p>"},{"location":"i2cDebugging/#3-bauelementdaten","title":"3. Bauelementdaten","text":"<p>Verwendete Bauteile:</p> <ul> <li>2x VL53L0X</li> <li>2x VL53L1X</li> <li>3x VL6180</li> <li>2x TCS3472 RGB Sensor</li> <li>L3GD20H Gyrosensor</li> <li>Oled Display 0,96 Zoll</li> </ul>"},{"location":"i2cDebugging/#4-messung-mit-dem-oszilloskop","title":"4. Messung mit dem Oszilloskop","text":"<p>Abb. 2.3: Ausschnitt einer Mussung der I\u00b2C Kommunikation</p> <p></p>"},{"location":"i2cDebugging/#5-messergebnisse-und-programmierung","title":"5. Messergebnisse und Programmierung","text":""},{"location":"i2cDebugging/#pandas","title":"Pandas","text":"<p>Das Pandas-Framework wird verwendet, um die <code>.csv</code>-Datei zu importieren und zu lesen, die aus der PicoScope7-Software exportiert wurde. Die Datei enth\u00e4lt 64 Buffer-Nummern und zeigt die Kommunikation zwischen dem Arduino Mega und den verwendeten Sensoren. Mit Pandas lassen sich die Daten einfach anzeigen und analysieren.</p>"},{"location":"i2cDebugging/#seaborn","title":"Seaborn","text":"<p>F\u00fcr die Datenanalyse und Visualisierung habe ich Seaborn verwendet, eine Python-Bibliothek, die auf Matplotlib basiert. Seaborn bietet eine benutzerfreundliche Schnittstelle f\u00fcr das Erstellen ansprechender und informativer statistischer Grafiken.</p> <p></p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\ndf = pd.read_csv(\"/path/to/your/file.csv\")\nprint(df.isna())\nprint(df.dropna())\n\ncmap = plt.get_cmap('viridis')\n\n\nsns.histplot(data=df, x=\"Address\", hue='Address', palette='Set1')\nplt.grid(True, axis='x', linestyle='')\nplt.xlabel(\"Addressen\")\nplt.ylabel(\"Anzahl der \u00dcbertragungen\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_Decoding\")\nplt.show()\n\nplt.title(\"Anzahl der Lese- und Schreibvorg\u00e4nge\")\nsns.barplot(data=df[\"R/W\"].value_counts(), palette=\"deep\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\nplt.ylabel(\"Anzahl der Vorg\u00e4nge\")\n\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_R_W\")\nplt.show()\n\ndf['Time'] = df[\"End Time\"] - df[\"Start Time\"]\nprint(df['Time'])\n\nduration = df['Time'].sum()\nprint(f'L\u00e4nge der Messung: {duration * 1000} ms')\n</code></pre>"},{"location":"languages/","title":"Programmiersprachen und Tools","text":""},{"location":"languages/#1-programmiersprachen","title":"1. Programmiersprachen","text":"<p>Der Schwerpunkt des Unterrichts an der Bulme lag auf der Programmiersprache C. In dieser Arbeit m\u00f6chte ich jedoch den Fokus auf ihren Nachfolger C++ legen. Ich habe C++ gew\u00e4hlt, da es gegen\u00fcber C einige entscheidende Vorteile bietet, wie beispielsweise die Unterst\u00fctzung von Klassen und Vererbung. Diese Eigenschaften sind besonders hilfreich bei der Verwaltung von Sensoren und der Verarbeitung der Daten.</p> <p>Weitere Programmiersprachen welche verwendet wurden sind:  </p> <ul> <li> <p>Python f\u00fcr das Programmieren der OpenMV Cam H7 und die Auswertung und Visualisierung der Messdaten</p> </li> <li> <p>HTML und Markdown f\u00fcr die Gestaltung der Diplomarbeit</p> </li> </ul>"},{"location":"languages/#2-tools","title":"2. Tools","text":"<p>Mein Interesse beschr\u00e4nkt sich nicht nur auf die Programmierung von Mikrokontrollern. Daher habe ich mir das Ziel gesetzt, diese Diplomarbeit mit modernen Tools umzusetzen, die frei zur Verf\u00fcgung stehen und auch in der Arbeitswelt gefragt sind.  </p> <p>Verwendet wurden unter anderem:</p> <ul> <li>PlatformIO: F\u00fcr die Programmierung des Arduino Mega.  </li> <li>Marimo: F\u00fcr die Bearbeitung der Messdaten und deren visuelle Darstellung.  </li> <li>Git/Github: Als Versionskontrollsystem zur Verwaltung des Projekts.  </li> <li>GitHub Pages und MkDocs: Zur Erstellung dieser Website.  </li> <li>KiCad: F\u00fcr die Gestaltung des Platinenlayouts.  </li> </ul>"},{"location":"pwm/","title":"Timer/Counter0 f\u00fcr die Pulsweitenmodulation mit dem Atmega2560","text":""},{"location":"pwm/#1-ubersicht","title":"1. \u00dcbersicht","text":"<p>Der Timer/Counter0 ist ein 8-Bit-Z\u00e4hlermodul mit zwei unabh\u00e4ngigen Vergleichseinheiten und Unterst\u00fctzung f\u00fcr die Pulsweitenmodulation (PWM). Diese Funktion erm\u00f6glicht die pr\u00e4zise Steuerung eines generierten Signals. Das folgende Blockdiagramm illustriert den Ablauf:</p> <p>Abb. 1.1: Blockdiagramm </p>"},{"location":"pwm/#2-register-uberblick","title":"2. Register \u00dcberblick","text":"<p>Die wichtigsten Register sind:</p> <ul> <li>TCNT0 (Timer/Counter)</li> <li>OCR0A und OCR0B (Output Compare Register)</li> </ul> <p>Diese 8-Bit-Register k\u00f6nnen individuell programmiert werden. Interrupts werden \u00fcber das Timer Interrupt Mask Register (TIMSK0) konfiguriert.  </p> <p>Der Timer/Counter kann mit dem internen Mikrokontroller-Takt oder einem externen Taktgeber am Pin T0 betrieben werden. Bei Nutzung des internen Takts kann der Prescaler im Register TCCR0B angepasst werden, um die Timer-Frequenz zu skalieren. Die Berechnung wird sp\u00e4ter genauer erl\u00e4utert.</p> <p>Die OCR0A- und OCR0B-Register werden fortlaufend mit dem Z\u00e4hlerwert verglichen. Das Ergebnis dieses Vergleichs kann zur Signalerzeugung genutzt werden.</p>"},{"location":"pwm/#3-detaillierte-registeranalyse-fur-pwm","title":"3. Detaillierte Registeranalyse f\u00fcr PWM","text":""},{"location":"pwm/#31-tccr0a","title":"3.1. TCCR0A","text":"<p>Im TCCR0A-Register wird das Bit WGM01 gesetzt, um den Timer in den Clear Timer on Compare Match (CTC)-Modus zu versetzen. In diesem Modus z\u00e4hlt der Timer bis zu einem definierten Wert und wird anschlie\u00dfend zur\u00fcckgesetzt.</p> <p>Abb. 3.1: TCCR0A </p>"},{"location":"pwm/#32-tccr0b","title":"3.2. TCCR0B","text":"<p>Im TCCR0B-Register wird das Bit CS01 gesetzt, um den CPU-Takt mit einem Prescaler von 8 zu verwenden.</p> <p>Abb. 3.2: TCCR0B </p>"},{"location":"pwm/#33-ocr0a","title":"3.3. OCR0A","text":""},{"location":"pwm/#331-funktion","title":"3.3.1. Funktion","text":"<p>Das OCR0A-Register enth\u00e4lt einen 8-Bit-Wert, der mit dem Z\u00e4hler verglichen wird. Bei \u00dcbereinstimmung kann ein Interrupt ausgel\u00f6st werden, der zur PWM genutzt wird. Mit einem Prescaler von 8 wird alle 100 \u00b5s ein Interrupt generiert.</p> <p>Abb. 3.3: OCR0A </p>"},{"location":"pwm/#332-berechnung-des-vergleichswertes","title":"3.3.2. Berechnung des Vergleichswertes","text":"<p>Das Ziel ist eine PWM mit 20 Hz f\u00fcr Servomotoren. Die Timer-Frequenz ergibt sich aus dem CPU-Takt und dem Prescaler:</p> \\[ f_{\\text{timertick}} = \\frac{16 \\cdot 10^6 \\, \\text{Hz}}{8} = 2 \\cdot 10^6 \\, \\text{Hz} \\] <p>Ein Timerimpuls wird alle 0,1 ms ben\u00f6tigt:</p> \\[ \\text{ticks}(x) = f_{\\text{timertick}} \\cdot x = 2 \\cdot 10^6 \\cdot 0.1 \\cdot 10^{-3} = 200 \\] <p>Der Vergleichswert ergibt sich zu:</p> \\[ OCR0A = \\text{ticks}(x) - 1 = 199 \\]"},{"location":"pwm/#34-timsk0","title":"3.4. TIMSK0","text":"<p>Im TIMSK0-Register wird das Bit OCIE0A gesetzt, um den Timer0-Interrupt bei einem Compare-Match zu aktivieren.</p> <p>Abb. 3.4: TCCR0B </p>"},{"location":"pwm/#4-grafische-darstellung-der-pwm","title":"4. Grafische Darstellung der PWM","text":"<p>Der modulierte Signalverlauf \u00fcber 3,5 ms zeigt unterschiedliche Pulsweiten, die zur Servomotorsteuerung genutzt werden.  </p>"},{"location":"pwm/#positionen-des-servomotors","title":"Positionen des Servomotors:","text":"<ul> <li>0\u00b0: 500 \u00b5s</li> <li>90\u00b0: 1450 \u00b5s</li> <li>180\u00b0: 2400 \u00b5s</li> </ul> <p>Abb. 4.1: Signal mit minimaler Pulsweite (1 ms) </p> <p>Abb. 4.2: Signal mit maximaler Pulsweite (2 ms) </p>"},{"location":"pwm/#5-frequenzanalyse-des-pwm-signals","title":"5. Frequenzanalyse des PWM-Signals","text":""},{"location":"pwm/#51-sampling-frequenz-und-auflosung","title":"5.1. Sampling-Frequenz und Aufl\u00f6sung","text":"<ul> <li>Die Sampling-Frequenz f_s = 3,13 MS/s erf\u00fcllt das Nyquist-Theorem:  $$ f_s &gt; 2 \\cdot f_{\\text{signal}} $$</li> </ul>"},{"location":"pwm/#52-spektrumverteilung","title":"5.2. Spektrumverteilung","text":"<ul> <li>Stark ged\u00e4mpft im h\u00f6heren Frequenzbereich (&lt; -60 dB).</li> </ul>"},{"location":"pwm/#53-charakteristische-frequenzkomponenten","title":"5.3. Charakteristische Frequenzkomponenten","text":"<ul> <li>Dominante Grundfrequenz sichtbar bei niedriger Frequenz.</li> </ul>"},{"location":"pwm/#54-rauschkomponenten","title":"5.4. Rauschkomponenten","text":"<ul> <li>Hohes Grundrauschen, besonders bei Frequenzen &gt; 0.5 MHz.</li> </ul> <p>Abb. 5.1 Analyse der Frequenzen </p>"},{"location":"pwm/#6-programmierung-der-pulsweitenmodulation","title":"6. Programmierung der Pulsweitenmodulation","text":"<pre><code>#include \"RS232.h\"\n#include \"ADU_ATMEGA2560 V21.h\"\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include &lt;util/delay.h&gt;\n#include &lt;Arduino.h&gt;\n\n#define SERVO_1_PIN PE5\n#define SERVO_1_DDR DDRE\n#define SERVO_1_PORT PORTE\n#define SERVO_2_PIN PG5\n#define SERVO_2_DDR DDRG\n#define SERVO_2_PORT PORTG\n\nvolatile uint8_t pulse_length_servo1 = 15;\nvolatile uint8_t pulse_length_servo2 = 15;\nvolatile bool move_to_180 = true;\n\nvoid setup()\n{\n    TCCR0A = (1 &lt;&lt; WGM01);\n    TCCR0B = (1 &lt;&lt; CS01);\n    OCR0A = 199;\n    TIMSK0 = (1 &lt;&lt; OCIE0A);\n\n    SERVO_1_DDR |= (1 &lt;&lt; SERVO_1_PIN);\n    SERVO_2_DDR |= (1 &lt;&lt; SERVO_2_PIN);\n\n    sei();\n\n    ADU_Init();\n    RS232_Init(RS232_NUR_EMPFANGEN);\n}\n\nvoid loop()\n{\n    if (Empfangen == 'u')\n    {\n        if (move_to_180)\n        {\n            pulse_length_servo1 = 24;\n            pulse_length_servo2 = 24;\n        }\n        else\n        {\n            pulse_length_servo1 = 5;\n            pulse_length_servo2 = 5;\n        }\n\n        move_to_180 = !move_to_180;\n        Empfangen = 0;\n    }\n}\n\nISR(TIMER0_COMPA_vect)\n{\n    static uint8_t counter = 0;\n\n    if (counter == 0)\n    {\n        SERVO_1_PORT |= (1 &lt;&lt; SERVO_1_PIN);\n        SERVO_2_PORT |= (1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    if (counter == pulse_length_servo1)\n    {\n        SERVO_1_PORT &amp;= ~(1 &lt;&lt; SERVO_1_PIN);\n    }\n    if (counter == pulse_length_servo2)\n    {\n        SERVO_2_PORT &amp;= ~(1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    counter++;\n    if (counter &gt;= 200)\n    {\n        counter = 0;\n    }\n}\n</code></pre>"},{"location":"pwm/#7-quellenangaben","title":"7. Quellenangaben","text":"<ul> <li> <p>Datenblatt 8-bit Atmel Microcontroller</p> </li> <li> <p>Prescaler Konfiguration</p> </li> <li> <p>Nyquist-Frequenz</p> </li> <li> <p>FFT und LowPass Filter Curio Res</p> </li> </ul>"},{"location":"ref/","title":"Quellenangaben","text":"<ul> <li> <p>Datenblatt 8-bit Atmel Microcontroller</p> </li> <li> <p>Prescaler Konfiguration</p> </li> <li> <p>Nyquist-Frequenz</p> </li> <li> <p>FFT und LowPass Filter Curio Res</p> </li> <li> <p>I2C von Texas Instrument</p> </li> </ul>"}]}