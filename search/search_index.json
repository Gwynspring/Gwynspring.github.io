{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"milestones/","title":"Meilensteine","text":"Juni 2025 <p>Training des Models f\u00fcr die Buchstabenerkennung und Implementierung in das System.</p> Mai 2025 <p>Refactoring des Codes zur Performance-Steigerung und Optimierung der Algorithmen.</p> April 2025 <p>Entwicklung und Implementierung des Pfadfindungsalgorithmus zur Navigation.</p> M\u00e4rz 2025 <p>Test der Platine und der Sensoren auf Funktionalit\u00e4t und Genauigkeit.</p> Februar 2025 <p>Design und mechanische Planung des Roboters f\u00fcr optimale Beweglichkeit.</p> J\u00e4nner 2025 <p>Entwurf und Erstellung der Platine mit allen notwendigen Schaltungen.</p> Dezember 2024 <p>Recherche und Programmierung der Sensoren zur Datenerfassung und Steuerung.</p> Mitte November 2024 <p>Erste Testl\u00e4ufe und Planung von Messversuchen zur Analyse des Roboters.</p> Anfang November 2024 <p>Start der Code-Strukturierung und Einrichtung eines Git-Repositories f\u00fcr die Projektentwicklung.</p> Ende Oktober 2024 <p>Erarbeitung eines klaren Projektkonzepts und Festlegung der Projektziele.</p> Mitte Oktober 2024 <p>Durchf\u00fchrung von Recherche und Ideensammlung zur Projektentwicklung.</p> Anfang Oktober 2024 <p>Erstellen der Grobstruktur und Begutachtung des Formulars zur Einreichung des Themas.</p> September 2024 <p>Thema eingrenzen, Inhalte, Formulare und Meilensteinplan besprechen und finalisieren.</p>"},{"location":"about/","title":"Home","text":""},{"location":"about/#dokumentation-fur-die-diplomarbeit-von","title":"Dokumentation f\u00fcr die Diplomarbeit von","text":"<p>Autor: Martin Gspurning</p> <p></p>"},{"location":"about/background/","title":"Ziele","text":""},{"location":"about/background/#ziel-der-diplomarbeit","title":"Ziel der Diplomarbeit","text":"<p>Ziel dieser Diplomarbeit ist die Konzeption und Entwicklung eines funktionsf\u00e4higen Bergeroboters, der beim RoboCup Junior zum Einsatz kommen soll. Obwohl eine Teilnahme aufgrund meines Alters au\u00dfer Konkurrenz erfolgt, orientiert sich der Entwurf vollst\u00e4ndig an den offiziellen Regeln und Vorgaben des Wettbewerbs.</p> <p>Der entwickelte Roboter soll folgende Anforderungen erf\u00fcllen:</p> <ul> <li>autonome Fortbewegung,</li> <li>\u00dcberwinden von Hindernissen und</li> <li>Ausf\u00fchren spezifischer Aufgaben wie das gezielte Abwerfen von Erste-Hilfe-Paketen.</li> </ul>"},{"location":"about/background/#umsetzung","title":"Umsetzung","text":"<p>Das Projekt basiert auf dem Arduino Mega 2560R3, welcher in der Programmiersprache C++ programmiert wird. Dieser Mikrocontroller bietet eine Vielzahl von Peripherieanschl\u00fcssen und ein breites Angebot an Open-Source-Ressourcen, die die Entwicklung unterst\u00fctzen.</p>"},{"location":"about/background/#ziel-und-motivation","title":"Ziel und Motivation","text":"<p>Mit dieser Diplomarbeit m\u00f6chte ich die w\u00e4hrend meiner Ausbildungszeit an der HTL-Bulme Graz G\u00f6sting erlernten Kenntnisse und F\u00e4higkeiten in einem interdisziplin\u00e4ren Projekt unter Beweis stellen. Dabei liegt der Fokus darauf, technische Konzepte wie Mikrocontroller-Programmierung, Kommunikationsprotokolle, Elektronik und Bildverarbeitung zu kombinieren, um ein funktionales Endprodukt zu schaffen.</p>"},{"location":"about/background/#inhalt-der-arbeit","title":"Inhalt der Arbeit","text":"<p>Diese Diplomarbeit umfasst folgende Schwerpunkte:</p> <ul> <li>Pulsweitenmodulation mit dem Timer/Counter-Register</li> <li>Kommunikation zwischen dem Arduino Mega 2560R3 (Master) und verschiedenen Sensoren (Slave) mittels I\u00b2C</li> <li>Messung von PWM- und I\u00b2C-Signalen mittels Oszilloskop und Analyse der Messergebnisse</li> <li>Entwurf und Design von Leiterplatten</li> <li>Buchstabenerkennung mittels OpenMV Cam H7 und Machine Learning mit Python</li> </ul> <p>Den vollst\u00e4ndigen Code sowie zus\u00e4tzliche Unterlagen wie Datenbl\u00e4tter und hilfreiche Artikel finden Sie auf MimsRC Github.</p>"},{"location":"about/motivation/","title":"Motivation","text":""},{"location":"about/motivation/#personlicher-hintergrund","title":"Pers\u00f6nlicher Hintergrund","text":"<p>Nach meiner Matura entschied ich mich f\u00fcr eine Doppellehre als Elektro- und Maschinenbautechniker. W\u00e4hrend meiner Lehrzeit habe ich meine Begeisterung f\u00fcr Elektrotechnik, die mir mein Gro\u00dfvater weitergegeben hat, neu entdeckt.  </p> <p>Nach der Lehre wollte ich mich weiterbilden und entschloss mich daher, das Abendkolleg f\u00fcr Elektrotechnik an der HTL Bulme Graz G\u00f6sting zu besuchen. Urspr\u00fcnglich wollte ich den Fachbereich Erneuerbare Energien w\u00e4hlen. Doch schon nach wenigen Wochen weckte der Informatikunterricht, insbesondere das Programmieren, mein Interesse.  </p> <p>Dieser Moment war f\u00fcr mich ein Wendepunkt \u2013 von da an war klar, dass die Automatisierungstechnik genau das Richtige f\u00fcr mich ist.  </p> <p>Im Unterricht wurde mir die Programmiersprache C vermittelt, eine hervorragende Grundlage, um die Prinzipien von Datentypen, Rechenoperationen und Speichermanagement zu verstehen. Diese fundierte Basis hat mich motiviert, mich auch privat mit anderen Programmiersprachen und Technologien auseinanderzusetzen \u2013 ein Vorteil, der mir bei dieser Diplomarbeit zugutekommt.  </p> <p>Die Idee zu diesem Projekt entstand durch meinen Informatik-Professor, Herrn Prof. DI Peter Frauscher, der mit seiner Faszination f\u00fcr Robotik meine Begeisterung weckte.  </p> <p>Mit diesem Projekt m\u00f6chte ich nicht nur meine F\u00e4higkeiten weiterentwickeln, sondern auch zeigen, wie moderne Technologie, auf HTL Niveau in die Praxis umgesetzt werden kann.</p>"},{"location":"about/motivation/#herausforderungen","title":"Herausforderungen","text":"<p>Die Umsetzung eines Bergeroboters f\u00fcr den RoboCup Junior bietet eine Vielzahl technischer und pers\u00f6nlicher Herausforderungen:  </p> <ul> <li>Die Kombination aus Softwareentwicklung und Hardwareintegration.  </li> <li>Die Nutzung von Sensorik, um die Umgebung zu erfassen.  </li> <li>Das Erstellen von Algorithmen, die autonomes Verhalten erm\u00f6glichen.  </li> </ul> <p>Ein weiterer wichtiger Aspekt ist die Erstellung einer umfassenden Dokumentation, um mein Projekt f\u00fcr Interessierte und Technikbegeisterte zug\u00e4nglich zu machen.  </p>"},{"location":"about/motivation/#fachliche-motivation","title":"Fachliche Motivation","text":"<p>W\u00e4hrend meiner Ausbildung an der HTL Bulme Graz G\u00f6sting habe ich fundierte Kenntnisse in Elektrotechnik, Elektronik und Softwareentwicklung erworben. Dieses Projekt gibt mir die Gelegenheit, diese F\u00e4higkeiten in einem praxisorientierten und interdisziplin\u00e4ren Kontext anzuwenden.  </p> <p>Besonders reizt mich die Entwicklung eines autonomen Systems, das in einer unbekannten Umgebung navigieren kann \u2013 eine echte technische Herausforderung, die meine Kreativit\u00e4t und mein technisches Know-how fordert.</p>"},{"location":"about/motivation/#langfristige-ziele","title":"Langfristige Ziele","text":"<p>Mit diesem Projekt m\u00f6chte ich nicht nur meine technischen Fertigkeiten weiter vertiefen, sondern auch meine Probleml\u00f6sungs- und Projektplanungsf\u00e4higkeiten erweitern.  </p> <p>Mein langfristiges Ziel ist es, in der Entwicklung moderner Technologien, insbesondere in den Bereichen Robotik und Automatisierung, t\u00e4tig zu sein. Dieses Projekt stellt f\u00fcr mich einen entscheidenden Meilenstein auf diesem Weg dar.</p>"},{"location":"appendix/ref/","title":"Literaturverzeichnis","text":"<ul> <li> <p>Wu, Joseph. A Basic Guide to I2C. Texas Instruments, 2022. https://www.ti.com/lit/an/sbaa565/sbaa565.pdf. Abgerufen am 9. Januar 2025.</p> </li> <li> <p>ATmega 640/V-1280/V-1281/V-2560/V-2561/V Datasheet. Microchip, 2014. https://ww1.microchip.com/downloads/aemDocuments/documents/OTH/ProductDocuments/DataSheets/ATmega640-1280-1281-2560-2561-Datasheet-DS40002211A.pdf. Abgerufen am 9. Januar 2025.</p> </li> <li> <p>Prescaler Konfiguration</p> </li> <li> <p>Nyquist-Frequenz</p> </li> <li> <p>MkDocs </p> </li> <li> <p>Material f\u00fcr MKDocs </p> </li> <li> <p>mkdocstrings</p> </li> <li> <p>PlatformIO</p> </li> <li> <p>Visual Studio Code</p> </li> <li> <p>Git</p> </li> <li> <p>Github</p> </li> <li> <p>Kaggle</p> </li> <li> <p>KiCad</p> </li> </ul>"},{"location":"assets/components/","title":"Bauteile","text":""},{"location":"assets/components/#verwendete-sensoren-aktoren-und-messgerate","title":"Verwendete Sensoren, Aktoren und Messger\u00e4te","text":"Sensor / Aktor / Messger\u00e4t Kommunikation Funktion Weitere Details Anzahl Arduino Mega2560R3 I\u00b2C / RS232 Mikrokontroller 54 digitale Pins und 16 analoge Eingangspins. 1 VL53L0X I\u00b2C Abstandssensor Reichweite bis 2m 2 VL53L1X I\u00b2C Abstandssensor Reichweite bis 4m 2 VL6180 I\u00b2C Abstandssensor Infrarot, Nahbereich 4 TCS3472 I\u00b2C RGB-Farbsensor Farberkennung 2 L3GD20H I\u00b2C Gyrosensor 3-Achsen-Gyrosensor 1 OLED Display I\u00b2C Anzeige 0,96 Zoll, 128x64 Pixel 1 LM2596 I\u00b2C Spannungsregler 3A Ausgang 1 Picoscope 2205A Oszilloskop USB Messung der Kommunikationen PWM, \\(I^2C\\) 1 OpenMV Cam H7 RS232 Buchstabenerkennung Kommunikation mit Arduino Mega \u00fcber RS232 2 SG92R Servomotor GPIO Auswurf der Pakete Steuerung \u00fcber PWM 2 FIT0522 DC-Motor GPIO Antrieb des Roboters PID geregelt 4 TB6612FNG Motordriver GPIO Steuerung der Motoren 1A Ausgang 2 Neopixel Ring 12 LED GPIO Signalisierung von Status 5.0V, 12x 18.5mA (max. 12x 55mA pro Modul) 1 Endschalter GPIO Anfahrschutz Links und rechts vorne 2"},{"location":"experiment/i2cDebugging/","title":"I\u00b2C Kommunikation","text":""},{"location":"experiment/i2cDebugging/#1-aufgabenstellung","title":"1. Aufgabenstellung","text":"<ul> <li>Gewinnung des Messsignals</li> <li>Festlegung der Struktur der Messeinrichtung</li> <li>Bestimmung der Signalformen</li> <li>\u00dcbertragung und Verarbeitung der Messsignale</li> <li>Ausgabe und Darstellung der gewonnenen Informationen</li> </ul>"},{"location":"experiment/i2cDebugging/#2-theoretische-grundlagen","title":"2. Theoretische Grundlagen","text":"<p>I\u00b2C ist ein Kommunikationsprotokoll, das zwei Leitungen \u2013 Serial Data Line (SDA) und Serial Clock Line (SCL) \u2013 verwendet.  Das Protokoll erm\u00f6glicht die Kommunikation zwischen mehreren Ger\u00e4ten, bei der jedes Ger\u00e4t eine eindeutige Adresse hat.  Es unterst\u00fctzt die \u00dcbertragung von Daten in Form von Byte-Paketen.</p>"},{"location":"experiment/i2cDebugging/#geschwindigkeitsmodi","title":"Geschwindigkeitsmodi","text":"<p>I\u00b2C-Kommunikation kann in den folgenden drei Modi erfolgen:</p> <ul> <li>Standardmode (Sm): 100 kbit/s</li> <li>Fastmode (Fm): 400 kbit/s</li> <li>Fastmode Plus (Fm+): 1 Mbit/s</li> </ul> <p>Abb. 1.1: Gegen\u00fcberstellung der Geschwindigkeitsmodi</p> <p> Quelle: Wu, Joseph, 2022, S.3</p>"},{"location":"experiment/i2cDebugging/#aufbau-des-i2c-bus","title":"Aufbau des I\u00b2C-Bus","text":"<p>Abb. 1.2: Schematischer Aufbau eines I\u00b2C Bussystems</p> <p></p> <p>(vgl. ebd.,S.4, Figure 2-1)</p>"},{"location":"experiment/i2cDebugging/#scl-serial-clock","title":"SCL (Serial Clock)","text":"<p>Die SCL-Leitung ist f\u00fcr den Takt der Kommunikation verantwortlich und wird vom Master gesteuert. Sie gibt den Rhythmus f\u00fcr die Daten\u00fcbertragung vor.</p>"},{"location":"experiment/i2cDebugging/#sda-serial-data","title":"SDA (Serial Data)","text":"<p>Die SDA-Leitung \u00fcbertr\u00e4gt die eigentlichen Daten zwischen den Ger\u00e4ten. Ein Controller kann Ausgabewerte an einen DAC senden oder Daten von einem ADC empfangen.</p>"},{"location":"experiment/i2cDebugging/#halbduplex-vs-vollduplex","title":"Halbduplex vs. Vollduplex","text":"<p>I\u00b2C ist ein halbduplexes Kommunikationsprotokoll, bei dem Daten nur in eine Richtung gleichzeitig flie\u00dfen k\u00f6nnen. Im Gegensatz dazu ist SPI ein vollduplexes Protokoll, das gleichzeitige Daten\u00fcbertragungen in beide Richtungen erm\u00f6glicht.</p> <p>Vorteile von I\u00b2C:</p> <ul> <li>Geringer Verdrahtungsaufwand</li> <li>Weniger ben\u00f6tigte Pins am Mikrocontroller</li> </ul>"},{"location":"experiment/i2cDebugging/#i2c-adressierung-und-busstruktur","title":"I\u00b2C Adressierung und Busstruktur","text":"<p>Der I\u00b2C-Bus nutzt eine Master-Slave-Struktur, wobei der Master die Kommunikation initiiert und steuert. Jedes Ger\u00e4t auf dem Bus hat eine eindeutige Adresse, die es ihm erm\u00f6glicht, mit anderen Ger\u00e4ten zu kommunizieren. Die SDA- und SCL-Leitungen sind mit allen Ger\u00e4ten auf dem Bus \u00fcber Open-Drain-Verbindungen verbunden, was Pull-up-Widerst\u00e4nde erfordert.</p>"},{"location":"experiment/i2cDebugging/#i2c-start-und-stoppbedingungen","title":"I\u00b2C Start- und Stoppbedingungen","text":"<p>Die Kommunikation wird mit einer START-Bedingung eingeleitet, wobei der Master die SDA-Leitung auf Low und dann die SCL-Leitung auf Low zieht. Die Kommunikation endet mit einer STOP-Bedingung, bei der beide Leitungen auf High gesetzt werden, um den Bus freizugeben.</p> <p>Abb. 1.3: Start- und Stoppvorgang der Kommunikation</p> <p> (vgl. ebd.,S.7, Figure 3-1)</p>"},{"location":"experiment/i2cDebugging/#3-bauelementdaten","title":"3. Bauelementdaten","text":"<p>Verwendete Bauteile:</p> <ul> <li>2x VL53L0X</li> <li>2x VL53L1X</li> <li>3x VL6180</li> <li>2x TCS3472 RGB Sensor</li> <li>L3GD20H Gyrosensor</li> <li>OLED Display 0,96 Zoll</li> </ul>"},{"location":"experiment/i2cDebugging/#4-messung-mit-dem-oszilloskop","title":"4. Messung mit dem Oszilloskop","text":"<p>Abb. 2.3: Versuchsaufbau </p> <p>Abb. 2.4: Detailansicht der Messspitzen</p> <p></p> <p>Abb. 2.5: Ausschnitt einer Messung der I\u00b2C-Kommunikation mit dem Oszilloskop</p> <p></p>"},{"location":"experiment/i2cDebugging/#5-messergebnisse-und-programmierung","title":"5. Messergebnisse und Programmierung","text":""},{"location":"experiment/i2cDebugging/#pandas","title":"Pandas","text":"<p>Das Pandas-Framework wird verwendet, um die <code>.csv</code>-Datei zu importieren, die aus der PicoScope7-Software exportiert wurde. Diese Datei enth\u00e4lt 64 Buffer-Nummern und zeigt die Kommunikation zwischen dem Arduino Mega und den verwendeten Sensoren. Pandas erleichtert die Anzeige und Analyse der Daten.</p>"},{"location":"experiment/i2cDebugging/#seaborn","title":"Seaborn","text":"<p>F\u00fcr die Analyse und Visualisierung der Daten wurde Seaborn, eine auf Matplotlib basierende Python-Bibliothek, verwendet. Seaborn bietet eine benutzerfreundliche Schnittstelle f\u00fcr das Erstellen attraktiver und informativer statistischer Grafiken.</p> <p></p> <p></p> <pre><code>import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# CSV-Datei laden\ndf = pd.read_csv(\"/path/to/your/file.csv\")\n\n# \u00dcberpr\u00fcfen auf fehlende Werte\nprint(df.isna())\nprint(df.dropna())\n\n# Farbschema festlegen\ncmap = plt.get_cmap('viridis')\n\n# Histogramm der I\u00b2C-Adressen\nsns.histplot(data=df, x=\"Address\", hue='Address', palette='Set1')\nplt.grid(True, axis='x', linestyle='')\nplt.xlabel(\"Adressen\")\nplt.ylabel(\"Anzahl der \u00dcbertragungen\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\n\n# Speichern und Anzeigen des Diagramms\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_Decoding\")\nplt.show()\n\n# Anzahl der Lese- und Schreibvorg\u00e4nge\nplt.title(\"Anzahl der Lese- und Schreibvorg\u00e4nge\")\nsns.barplot(data=df[\"R/W\"].value_counts(), palette=\"deep\")\nsns.set_style('whitegrid')\nplt.gca().set_facecolor('#F7F7F7')\nplt.ylabel(\"Anzahl der Vorg\u00e4nge\")\n\n# Speichern und Anzeigen des Diagramms\nplt.savefig(\"/path/to/save/directory/I2C_MimsRC_R_W\")\nplt.show()\n\n# Berechnung der Zeitdifferenz\ndf['Time'] = df[\"End Time\"] - df[\"Start Time\"]\nprint(df['Time'])\n\n# Gesamtdauer der Messung\nduration = df['Time'].sum()\nprint(f'L\u00e4nge der Messung: {duration * 1000} ms')\n</code></pre>"},{"location":"experiment/pwm/","title":"Timer/Counter0 f\u00fcr die Pulsweitenmodulation mit dem Atmega2560","text":""},{"location":"experiment/pwm/#1-ubersicht","title":"1. \u00dcbersicht","text":"<p>Der Timer/Counter0 ist ein 8-Bit-Z\u00e4hlermodul mit zwei unabh\u00e4ngigen Vergleichseinheiten und Unterst\u00fctzung f\u00fcr die Pulsweitenmodulation (PWM). Diese Funktion erm\u00f6glicht die pr\u00e4zise Steuerung eines generierten Signals. Das folgende Blockdiagramm illustriert den Ablauf:</p> <p>Abb. 1.1: Blockdiagramm  Quelle: ATmega Datenblatt, 2014, S.115, Figure 16-1</p>"},{"location":"experiment/pwm/#2-register-uberblick","title":"2. Register \u00dcberblick","text":"<p>Die wichtigsten Register sind:</p> <ul> <li>TCNT0 (Timer/Counter)</li> <li>OCR0A und OCR0B (Output Compare Register)</li> </ul> <p>Diese 8-Bit-Register k\u00f6nnen individuell programmiert werden. Interrupts werden \u00fcber das Timer Interrupt Mask Register (TIMSK0) konfiguriert.</p> <p>Der Timer/Counter kann mit dem internen Mikrokontroller-Takt oder einem externen Taktgeber am Pin T0 betrieben werden. Bei Nutzung des internen Takts kann der Prescaler im Register TCCR0B angepasst werden, um die Timer-Frequenz zu skalieren. Die Berechnung wird sp\u00e4ter genauer erl\u00e4utert.</p> <p>Die OCR0A- und OCR0B-Register werden fortlaufend mit dem Z\u00e4hlerwert verglichen. Das Ergebnis dieses Vergleichs kann zur Signalerzeugung genutzt werden.</p>"},{"location":"experiment/pwm/#3-detaillierte-registeranalyse-fur-pwm","title":"3. Detaillierte Registeranalyse f\u00fcr PWM","text":""},{"location":"experiment/pwm/#31-tccr0a","title":"3.1. TCCR0A","text":"<p>Im TCCR0A-Register wird das Bit WGM01 gesetzt, um den Timer in den Clear Timer on Compare Match (CTC)-Modus zu versetzen. In diesem Modus z\u00e4hlt der Timer bis zu einem definierten Wert und wird anschlie\u00dfend zur\u00fcckgesetzt.</p> <p>Abb. 3.1: TCCR0A  (vgl. ebd.,S.126)</p>"},{"location":"experiment/pwm/#32-tccr0b","title":"3.2. TCCR0B","text":"<p>Im TCCR0B-Register wird das Bit CS01 gesetzt, um den CPU-Takt mit einem Prescaler von 8 zu verwenden.</p> <p>Abb. 3.2: TCCR0B  (vgl. ebd.,S.129)</p>"},{"location":"experiment/pwm/#33-ocr0a","title":"3.3. OCR0A","text":""},{"location":"experiment/pwm/#331-funktion","title":"3.3.1. Funktion","text":"<p>Das OCR0A-Register enth\u00e4lt einen 8-Bit-Wert, der mit dem Z\u00e4hler verglichen wird. Bei \u00dcbereinstimmung kann ein Interrupt ausgel\u00f6st werden, der zur PWM genutzt wird. Mit einem Prescaler von 8 wird alle 100 \\(\u00b5s\\) ein Interrupt generiert.</p> <p>Abb. 3.3: OCR0A  (vgl. ebd.,S.130)</p>"},{"location":"experiment/pwm/#332-berechnung-des-vergleichswertes","title":"3.3.2. Berechnung des Vergleichswertes","text":"<p>Das Ziel ist eine PWM mit 20 \\(Hz\\) f\u00fcr Servomotoren. Die Timer-Frequenz ergibt sich aus dem CPU-Takt und dem Prescaler:</p> \\[ f_{\\text{timertick}} = \\frac{16 \\cdot 10^6 \\, \\text{Hz}}{8} = 2 \\cdot 10^6 \\, \\text{Hz} \\] <p>Ein Timerimpuls wird alle 0,1 \\(ms\\) ben\u00f6tigt:</p> \\[ \\text{ticks}(x) = f\\_{\\text{timertick}} \\cdot x = 2 \\cdot 10^6 \\, \\text{Hz} \\cdot (0.1 \\cdot 10^{-3}) \\, \\text{s} = 200 \\] <p>Der Vergleichswert ergibt sich zu:</p> \\[ OCR0A = \\text{ticks}(x) - 1 = 199 \\]"},{"location":"experiment/pwm/#34-timsk0","title":"3.4. TIMSK0","text":"<p>Im TIMSK0-Register wird das Bit OCIE0A gesetzt, um den Timer0-Interrupt bei einem Compare-Match zu aktivieren.</p> <p>Abb. 3.4: TIMSK0  (vgl. ebd.,S.131)</p>"},{"location":"experiment/pwm/#5-versuchsaufbau","title":"5. Versuchsaufbau","text":"<p>Abb. 5.1: Messung der Pulsweitenmodulation f\u00fcr einen Servomotor </p>"},{"location":"experiment/pwm/#4-grafische-darstellung-der-pwm","title":"4. Grafische Darstellung der PWM","text":"<p>Der modulierte Signalverlauf \u00fcber 3,5 \\(ms\\) zeigt unterschiedliche Pulsweiten, die zur Servomotorsteuerung genutzt werden.</p>"},{"location":"experiment/pwm/#positionen-des-servomotors","title":"Positionen des Servomotors:","text":"<ul> <li>0\u00b0: 500 \\(\u00b5s\\)</li> <li>90\u00b0: 1450 \\(\u00b5s\\)</li> <li>180\u00b0: 2400 \\(\u00b5s\\)</li> </ul> <p>Abb. 4.1: Signal mit 1ms Pulsweite </p> <p>Abb. 4.2: Signal mit 2ms Pulsweite </p>"},{"location":"experiment/pwm/#5-frequenzanalyse-des-pwm-signals","title":"5. Frequenzanalyse des PWM-Signals","text":""},{"location":"experiment/pwm/#51-sampling-frequenz-und-auflosung","title":"5.1. Sampling-Frequenz und Aufl\u00f6sung","text":"<ul> <li>Die Sampling-Frequenz \\(f_s = 3,13 MS/s\\) erf\u00fcllt das Nyquist-Theorem:   $$   f_s &gt; 2 \\cdot f_{\\text{signal}}   $$</li> </ul>"},{"location":"experiment/pwm/#52-spektrumverteilung","title":"5.2. Spektrumverteilung","text":"<ul> <li>Stark ged\u00e4mpft im h\u00f6heren Frequenzbereich (\\(&lt; -60 dB\\)).</li> </ul>"},{"location":"experiment/pwm/#53-charakteristische-frequenzkomponenten","title":"5.3. Charakteristische Frequenzkomponenten","text":"<ul> <li>Dominante Grundfrequenz sichtbar bei niedriger Frequenz.</li> </ul>"},{"location":"experiment/pwm/#54-rauschkomponenten","title":"5.4. Rauschkomponenten","text":"<ul> <li>Hohes Grundrauschen, besonders bei Frequenzen &gt; 0.5 MHz.</li> </ul> <p>Abb. 5.1 Analyse der Frequenzen </p>"},{"location":"experiment/pwm/#6-programmierung-der-pulsweitenmodulation","title":"6. Programmierung der Pulsweitenmodulation","text":"<pre><code>#include \"RS232.h\"\n#include \"ADU_ATMEGA2560 V21.h\"\n#include &lt;avr/io.h&gt;\n#include &lt;avr/interrupt.h&gt;\n#include &lt;util/delay.h&gt;\n#include &lt;Arduino.h&gt;\n\n#define SERVO_1_PIN PE5\n#define SERVO_1_DDR DDRE\n#define SERVO_1_PORT PORTE\n#define SERVO_2_PIN PG5\n#define SERVO_2_DDR DDRG\n#define SERVO_2_PORT PORTG\n\nvolatile uint8_t pulse_length_servo1 = 15;\nvolatile uint8_t pulse_length_servo2 = 15;\nvolatile bool move_to_180 = true;\n\nvoid setup()\n{\n    TCCR0A = (1 &lt;&lt; WGM01);\n    TCCR0B = (1 &lt;&lt; CS01);\n    OCR0A = 199;\n    TIMSK0 = (1 &lt;&lt; OCIE0A);\n\n    SERVO_1_DDR |= (1 &lt;&lt; SERVO_1_PIN);\n    SERVO_2_DDR |= (1 &lt;&lt; SERVO_2_PIN);\n\n    sei();\n\n    ADU_Init();\n    RS232_Init(RS232_NUR_EMPFANGEN);\n}\n\nvoid loop()\n{\n    if (Empfangen == 'u')\n    {\n        if (move_to_180)\n        {\n            pulse_length_servo1 = 24;\n            pulse_length_servo2 = 24;\n        }\n        else\n        {\n            pulse_length_servo1 = 5;\n            pulse_length_servo2 = 5;\n        }\n\n        move_to_180 = !move_to_180;\n        Empfangen = 0;\n    }\n}\n\nISR(TIMER0_COMPA_vect)\n{\n    static uint8_t counter = 0;\n\n    if (counter == 0)\n    {\n        SERVO_1_PORT |= (1 &lt;&lt; SERVO_1_PIN);\n        SERVO_2_PORT |= (1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    if (counter == pulse_length_servo1)\n    {\n        SERVO_1_PORT &amp;= ~(1 &lt;&lt; SERVO_1_PIN);\n    }\n    if (counter == pulse_length_servo2)\n    {\n        SERVO_2_PORT &amp;= ~(1 &lt;&lt; SERVO_2_PIN);\n    }\n\n    counter++;\n    if (counter &gt;= 200)\n    {\n        counter = 0;\n    }\n}\n</code></pre>"},{"location":"language_tools/cpp/","title":"C++","text":""},{"location":"language_tools/cpp/#uberblick","title":"\u00dcberblick","text":"<p>Die Programmiersprache C++ wurde f\u00fcr die Programmierung des Arduino Mega 2560 verwendet. Sie bietet im Vergleich zu C zus\u00e4tzliche Funktionen wie Klassen, Vererbung und Polymorphismus, die die Entwicklung strukturierter und wiederverwendbarer Software erleichtern.</p>"},{"location":"language_tools/cpp/#vorteile-von-c","title":"Vorteile von C++","text":"<ul> <li>Unterst\u00fctzung f\u00fcr objektorientierte Programmierung.</li> <li>Bessere Organisation von Code durch Klassen.</li> <li>Effiziente Nutzung von Ressourcen dank direkter Speicherverwaltung.  </li> </ul>"},{"location":"language_tools/cpp/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<ul> <li>Steuerung der Motoren und Sensoren des Roboters.</li> <li>Verwaltung der Kommunikationsprotokolle (z. B. I\u00b2C).</li> <li>Nutzung von Timern und Interrupts zur Erzeugung von PWM-Signalen.  </li> </ul>"},{"location":"language_tools/git/","title":"Git und GitHub","text":""},{"location":"language_tools/git/#uberblick","title":"\u00dcberblick","text":"<p>Git ist ein Versionskontrollsystem, das es erm\u00f6glicht, den Code zu verwalten und \u00c4nderungen die von mir get\u00e4tigt wurden  nachzuvollziehen. GitHub ist eine Plattform, die Git zur Verwaltung von Repositories nutzt und zus\u00e4tzlich Werkzeuge f\u00fcr die Zusammenarbeit mit anderen Entwicklern bietet.</p>"},{"location":"language_tools/git/#vorteile-von-gitgithub","title":"Vorteile von Git/GitHub","text":"<ul> <li>Versionskontrolle: Git erm\u00f6glicht es, \u00c4nderungen am Projekt vorzunehmen und jederzeit zu einer fr\u00fcheren Version zur\u00fcckzukehren, solange zuvor ein Commit gemacht wurde.</li> <li>Zusammenarbeit: GitHub erleichtert die Zusammenarbeit, indem \u00c4nderungen \u00fcberpr\u00fcft und Pull Requests erstellt werden k\u00f6nnen, um den Code gemeinsam zu entwickeln.</li> <li>Cloud-basiert: Durch das Hosting auf GitHub ist der Code jederzeit und von \u00fcberall zug\u00e4nglich. </li> <li>Integration: GitHub l\u00e4sst sich nahtlos in viele andere Tools integrieren, wie z.B. in MkDocs zur Erstellung der Dokumentation.</li> </ul>"},{"location":"language_tools/git/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<p>In diesem Projekt wurden Git und GitHub f\u00fcr folgende Zwecke verwendet: - Versionskontrolle des Codes: Jedes Update und jede \u00c4nderung des Codes wurde mit Git verfolgt und auf GitHub gepusht. Besonders n\u00fctzlich ist hierbei der Befehl <code>git log</code>, um den Zeitstrahl mit den Commit-Kommentaren einzusehen. - Projektmanagement: GitHub Issues wurden verwendet, um Aufgaben und Fehler zu dokumentieren. Diese Issues sind direkt in MkDocs integriert, sodass Kommentare und Feedback meines Betreuers auf der Website hinterlegt werden und automatisch ins Repository \u00fcbertragen werden. Dadurch kann ich diese direkt bearbeiten und verfolgen. - Zusammenarbeit: Der Code kann von zuk\u00fcnftigen Projektpartnern oder Mitwirkenden eingesehen und in eigenen Branches erweitert oder optimiert werden. GitHub erm\u00f6glicht es, \u00c4nderungen transparent und nachvollziehbar zu gestalten. - Backup und Cloud-Hosting: Der gesamte Code wird auf GitHub gespeichert, was eine einfache Sicherung und den jederzeitigen Zugriff auf das Projekt erm\u00f6glicht.</p>"},{"location":"language_tools/kicad/","title":"KiCad","text":""},{"location":"language_tools/kicad/#uberblick","title":"\u00dcberblick","text":"<p>KiCad ist eine Open-Source-Software, mit der Leiterplatten entworfen und die erforderlichen Gerber-Dateien f\u00fcr die Fertigung erstellt werden k\u00f6nnen. Die Software stellt alle notwendigen Tools f\u00fcr den gesamten Designprozess bereit \u2013 vom Schaltplan (Schematics) \u00fcber die Bauteilzuordnung bis hin zum 3D-Rendering der fertigen Platine.</p>"},{"location":"language_tools/kicad/#vorteile-von-kicad","title":"Vorteile von KiCad","text":"<ul> <li>Open-Source und kostenlos</li> <li>All-in-One-L\u00f6sung f\u00fcr die Erstellung von Leiterplatten</li> <li>Benutzerfreundlich und leicht erlernbar</li> <li>Ausf\u00fchrliche Dokumentation und eine gro\u00dfe Community</li> </ul>"},{"location":"language_tools/kicad/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<p>KiCad wurde f\u00fcr das vollst\u00e4ndige Design der Platine verwendet, von der Erstellung der Schaltpl\u00e4ne bis hin zur Generierung der Gerber-Dateien.</p>"},{"location":"language_tools/marimo/","title":"Marimo","text":""},{"location":"language_tools/marimo/#uberblick","title":"\u00dcberblick","text":"<p>Marimo ist ein Open-Source-Notebook f\u00fcr Python, das besonderen Wert auf Reproduzierbarkeit legt und gut mit Git integriert werden kann. </p> <p>Der in Marimo geschriebene Code kann als Skript ausgef\u00fchrt werden, da das Notebook urspr\u00fcnglich als <code>.py</code> Datei konzipiert ist. Zudem bietet Marimo die M\u00f6glichkeit, das Notebook als App zu teilen oder die Datei in verschiedenen Formaten wie HTML, Markdown oder PDF herunterzuladen. </p>"},{"location":"language_tools/marimo/#vorteile-von-marimo","title":"Vorteile von Marimo","text":"<ul> <li>Modernes Notebook mit einem klaren Fokus auf Reproduzierbarkeit.</li> <li>Erm\u00f6glicht die einfache Integration interaktiver Widgets, wie z.B. Slider, f\u00fcr eine dynamische Codegestaltung.</li> <li>Unterst\u00fctzt LaTeX f\u00fcr mathematische Ausdr\u00fccke.</li> <li>Kann direkt als <code>.py</code> Datei ausgef\u00fchrt werden.</li> <li>Bietet ein \u201eScratchbook\u201c f\u00fcr schnelle Codeversuche au\u00dferhalb der Hauptdatei.</li> </ul>"},{"location":"language_tools/marimo/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<ul> <li>Auswertung und Berechnung der Messdaten.</li> <li>Visualisierung von Messwerten und Ergebnissen.</li> </ul>"},{"location":"language_tools/mkdocstring/","title":"mkdocstrings","text":""},{"location":"language_tools/mkdocstring/#uberblick","title":"\u00dcberblick","text":"<p>mkdocstrings </p>"},{"location":"language_tools/mkdocstring/#vorteile-von-mkdocstrings","title":"Vorteile von mkdocstrings","text":""},{"location":"language_tools/mkdocstring/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":""},{"location":"language_tools/python/","title":"Python","text":""},{"location":"language_tools/python/#uberblick","title":"\u00dcberblick","text":"<p>Die Programmiersprache Python wurde in verschiedenen Bereichen der Diplomarbeit eingesetzt. Sie kam unter anderem bei der Vorbereitung der Trainingsdaten f\u00fcr das Buchstabenerkennungsmodell sowie bei der Visualisierung von Messdaten aus den verschiedenen Funktionalit\u00e4tsmessungen des Roboters mit dem Oszilloskop zum Einsatz. Weitere Details dazu finden sich im Abschnitt \u00fcber \\(I^2C\\).</p>"},{"location":"language_tools/python/#vorteile-von-python","title":"Vorteile von Python","text":"<ul> <li>Beliebte Programmiersprache mit einer Vielzahl an n\u00fctzlichen Frameworks und Tools.</li> <li>Hervorragende Integration mit anderen Programmen wie LaTeX.</li> <li>Einfaches Erstellen von Diagrammen und Messwertvisualisierungen.</li> <li>Umfangreiche State-of-the-Art Data Science-Frameworks.</li> </ul>"},{"location":"language_tools/python/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<ul> <li>Steuerung der OpenMV Cam H7 und \u00dcbertragung von Informationen an den Arduino Mega 2560.</li> <li>Bildvorbereitung f\u00fcr das Training des Buchstabenerkennungsmodells.</li> <li>Durchf\u00fchrung von Berechnungen mit den Messdaten aus den Messversuchen.</li> <li>Animation von Abl\u00e4ufen mit Manim zur besseren Visualisierung und einem besseren Verst\u00e4ndnis der Abl\u00e4ufe.</li> </ul>"},{"location":"language_tools/start_methods/","title":"Programmiersprachen und Tools","text":"<p>Dieses Kapitel gibt einen \u00dcberblick \u00fcber die in dieser Diplomarbeit verwendeten Programmiersprachen und Tools. F\u00fcr Details zu einer bestimmten Sprache oder einem Tool klicken Sie auf die entsprechenden Links.</p>"},{"location":"language_tools/start_methods/#programmiersprachen","title":"Programmiersprachen","text":"<ul> <li>C++: Hauptsprache f\u00fcr die Entwicklung auf dem Arduino Mega 2560.  </li> <li>Python: F\u00fcr Bildverarbeitung, Datenanalyse und Visualisierung.  </li> <li>HTML und Markdown: F\u00fcr Dokumentation und Website-Gestaltung.  </li> </ul>"},{"location":"language_tools/start_methods/#tools","title":"Tools","text":"<ul> <li>Visual Studio Code: Die IDE meiner Wahl f\u00fcr alle Programmiersprachen.  </li> <li>PlatformIO: Erweiterung f\u00fcr die Programmierung des Arduino Mega.  </li> <li>Marimo: Modernes Notebook zur Messdatenanalyse und Visualisierung.  </li> <li>Git/GitHub: Versionskontrolle und Projektverwaltung.  </li> <li>Mkdocstring: Zur Dokumentation des Codes.  </li> <li>KiCad: Open Source Tool zur Gestaltung des Platinenlayouts.  </li> </ul>"},{"location":"language_tools/vscode/","title":"Visual Studio Code und PlatformIO","text":""},{"location":"language_tools/vscode/#uberblick","title":"\u00dcberblick","text":"<p>Die integrierte Entwicklungsumgebung Visual Studio Code (VS Code) ist eine plattform\u00fcbergreifende IDE (Integrated Development Environment), die eine hohe Anpassbarkeit der Entwicklungsumgebung erm\u00f6glicht. In dieser Umgebung habe ich das Tool PlatformIO installiert, das das Programmieren, Kompilieren und anschlie\u00dfende Hochladen des Codes erm\u00f6glicht.</p>"},{"location":"language_tools/vscode/#vorteile-von-vs-code","title":"Vorteile von VS Code","text":"<ul> <li>Eine der beliebtesten IDEs mit einer Vielzahl an n\u00fctzlichen Plug-ins.</li> <li>All-in-One-L\u00f6sung f\u00fcr die meisten g\u00e4ngigen Programmiersprachen.</li> <li>Vorschau von HTML- und Markdown-Code direkt im Editor.</li> <li>Erm\u00f6glicht die Vorschau von einzelnen Abschnitten der Manim-Animationen.</li> <li>Umfangreiche Dokumentation und starke Community.</li> </ul>"},{"location":"language_tools/vscode/#einsatz-in-diesem-projekt","title":"Einsatz in diesem Projekt","text":"<p>Der Gro\u00dfteil der Entwicklungsarbeit wurde in Visual Studio Code durchgef\u00fchrt, insbesondere f\u00fcr das Schreiben von Code und das Erstellen von Dokumentationen f\u00fcr das Projekt.</p>"}]}